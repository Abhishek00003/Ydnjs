# Вы не знаете JS: Асинхронность и Производительность
# Глава 2: Колбэки

В Главе 1 мы изучили термины и концепции, связанные с асинхронным программированием на Jacascript. Мы сосредоточились на изучении работы однопоточной очереди цикла событий, которая «управляет» всеми событиями (асинхронными вызовами функций). Мы также изучали различные способы, которыми шаблоны параллелизма объясняют взаимосвязь (если она есть!) между одновременно запущенными цепочками событий или «процессами» (задачами, вызовами функций и т. д.).

Все наши примеры в Главе 1 использовали функцию, как индивидуальную, неделимую единицу операций, внутри которой выполнялись операторы в предсказуемом порядке. Однако при вызове этих функций порядок может не соблюдаться.

Во всех этих случаях функция действует как «колбэк». Всякий раз она «возвращается» в программу, при обработке этого элмента в очереди цикла событий.

Как вы, несомненно, заметили, колбеки на сегодняшний день являются наиболее распространенным способом выражения и управления асинхронностью в программах на JS. Действительно, колбэк — это самый фундаментальный асинхронный шаблон в JS.


Множество JS-программ, даже очень сложных, были написаны с использованием колбэков (разумеется, вместе с шаблонами параллелизма, которые мы исследовали в главе 1). Колбэки - это асинхронная рабочая лошадка для JavaScript, и она выполняет свою работу с достоинством.

Кроме того... колбэки не лишены недостатков. Многие разработчики в восторге от промисов — лучшего асинхронного шаблона. Но невозможно эффективно использовать абстракцию, если вы не понимать, что лежит в ее основе.

В этой главе мы рассмотрим пару таких абстракций. Это нужно для понимания необходимости использования более сложных асихронных шаблонов (они будут рассмотрены в следующих главах).

## Continuations

Вернемся к примеруколбэка, который мы начали в главе 1, но позвольте мне немного изменить его:

```javascript
// A
ajax( "..", function(..){
  // C
} );
// B
```

`//A` и `//B` представляют первую половину программы («сейчас»), часть `//C` вторую половину («потом»). Первая часть выполнится, как надо. Потом наступит пауза непонятной длины. В какой то момент, если Ajax-запрос завершится, программа продолжит выполнение с того места, где она остановилась. Вторая половина будет выполнена.

Иными словами, колбэк инкапсулирует «продолжение выполнения» программы.

Давайте еще упростим наш пример:

```javascript
// A
setTimeout( function(){
  // C
}, 1000 );
// B
```

Остановитесь на мгновение и спросите себя, как бы вы объяснили (кому-то еще менее информированному о том, как работает JS), как ведет себя эта программа. Попробуйие вслух. Это хорошее упражнение, которое поможет следующим вопросам иметь больше смысла.

Большинство читателей, вероятно, подумали или сказали что-то вроде: «Выполнится A, затем установится тайм-аут, чтобы подождать 1000 миллисекунд, а затем, когда это срабатывает, выполнится C.». Насколько верно ваше толкование?

Вы, возможно, заметили подвох и сказали: «Выполнится A, затем установится тайм-аут тайм-аут на 1000 миллисекунд, выполнится B, а затем, после того, как тайм-аут пройдет, выполнится C.». Это более точное толкование, чем первая версия. Заметили разницу?

Несмотря на то, что вторая версия более точная, обе версии недостаточно объясняют выполнение этого кода.

Как только мы вводим одно продолжение (или несколько десятков тысяч программ!) В виде функции обратного вызова, мы разрешили расхождение между тем, как работают наши мозги и как работает код. Каждый раз, когда эти двое расходятся (и это далеко не единственное место, которое, как я уверен, вы знаете!), Мы сталкиваемся с неизбежным фактом, что наш код становится сложнее понять, рассуждать, отлаживать и поддерживать.

## Sequential Brain

Я почти уверен, что большинство читателей слышали, как кто-то сказал (даже сам утверждал): «Я многозадачник». Многозадачность может проявляться по-разному — от юмористического (например, глупой игры поглаживания головы-потирания живота) до обывательского (жевать жвачку при ходьбе) или до совершенно опасного (читать будучи за рулем).

Но многозадачники ли мы? Можем ли мы на самом деле делать сразу два осознанных, преднамеренных действия и думать / рассуждать о них в один и тот же момент? Человеческий мозг имеет высшый уровень функциональности, но может ли он работать параллельно-мультипоточно?

Ответ может вас удивить: возможно, нет.


Это не так просто, разобраться в «настройках» нашего мозга. Все-таки стоит признаться, что наш мозг гораздо более «однозадачен». Мы действительно можем думать только об одном в любой момент.

Я не говорю о всех наших непроизвольных, подсознательных, автоматических функциях мозга, таких как сердцебиение, дыхание и мигание век. Все это жизненно важные задачи , но мы не управляем ими намеренно. К счастью, пока мы в 15-й раз за три минуты проверяем ленту социальных сетей, наш мозг продолжает работать в фоновом режиме (потоки!) со всеми этими важными задачами.

Вместо этого мы говорим о том, какая задача находится в нашем разуме в данный момент. Для меня это написание текста в этой книге прямо сейчас. Выполняется ли в этот момент какая-либо другая функция высокого уровня? Нет, не совсем. Я отвлекаюсь быстро и легко - несколько десятков раз в этих последних параграфах!

Возникает ощущение «ложной» многозадачности. Мы пытаемся делать разные вещи одновременно, мы разговариваем с другом или членом семьи по телефону. Другими словами, мы переключаемся вперед и назад между двумя или более задачами в быстрой последовательности, одновременно продвигаясь по каждой задаче в маленьких маленьких быстрых частях. Мы делаем это так быстро, что для внешнего мира кажется, что мы делаем это параллельно.

Это звучит так же подозрительно, как асинхронный параллелизм (вроде того, что происходит в JS)? Если нет, вернитесь и снова прочитайте главу 1!

С радостью упомяну об одной аналогии, упрощающей понимание мозговой неврологии. Наш мозг работает, как очередь цикла событий.

Набор буквы или слова можно представить, как асинхронное событие, которое может прерываться десятком других событий (например, моими чувствами или мыслями).

Я не прерываю и не прикладываю к другому «процессу» при каждой возможности, которую я мог бы (к счастью, или эта книга никогда не будет написана!). Но это случается достаточно часто, когда я чувствую, что мой собственный мозг почти постоянно переключается на различные контексты (например, «процессы»). И это очень похоже на то, как, вероятно, почувствовал бы двигатель JS.

Я не прерываюсь и не перехожу к другому «процессу» при первой возможности (и это хорошо, иначе я бы не дописал эту книгу). Но такие прерыванния случаются довольно часто, мо   мозг почти постоянно переключается на различные переключается на различные контексты (например, «процессы»).
И это очень похоже на раблту движка JS.

## Выполнение или Планирование

Хорошо, условиимся рассматривать наши мозги, как работающие в однопоточной очереди цикла событий, как в JS. Неплохое сравнение.

Однако существует большая, заметная разница между тем, как мы планируем различные задачи, и как наш мозг фактически управляют этими задачами.

Опять же, вернемся к написанию этого текста в качестве метафоры. Мой грубый ментальный план заключается в том, чтобы продолжать писать и писать, последовательно по плану, который я «набросал» в своей голове. Я не планирую никаких прерываний или другой активности при письме. Но тем не менее, мой мозг все же переключается все время.

Несмотря на то, что на операционном уровне наш мозг асинхронный, мы, похоже, планируем задачи последовательно, синхронно. «Мне нужно пойти в магазин, потом купить молока, а потом постирать белье».

Кажется, что формулировке планирования нет ничего асинхронного. На самом деле, это редкость для нас сознательно думать исключительно о событиях. Вместо этого мы планируем все тщательно, последовательно (A, затем B, затем C), и мы предполагаем своего рода временную блокировку, которая заставляет B ждать события A и C ждать события B.

Когда разработчик пишет код, он планируют выполнить ряд действий. Если это хороший разработчик, он тщательно планирует это. «Мне нужно установить `z` значение `x`, а затем `x` значение `y`» и так далее.

Когда мы пишем синхронный код, оператор за оператором, он очень похож на ToDo-лист:

```javascript
z = x;
x = y;
y = z;
```
Эти три оператора присваивания являются синхронными, а значит `x = y` ждет завершения `z = x`, и `y = z`, в свою очередь, ждет завершения `x = y`. Другой способ это указать, что эти три утверждения связаны временем с выполнением в определенном порядке, один за другим. К счастью, нам не нужно беспокоиться о каких-либо асинхронных событиях здесь. Если бы мы это сделали, код стал бы намного сложнее!

Итак, синхронное планирование мозга хорошо работает с синхронными операторами кода. Насколько хорошо наши мозг работает при планировании асинхронного кода?

Оказывается, описание асинхронности (с помощью колбэков) в нашем коде, не очень хорошо соотносится с синхронным планированием мозга.

Можете ли вы представить такую ситуацию?

Мне нужно пойти в магазин, но по дороге я уверен, что мне позвонят, так что «Привет, мам», и когда она заговорит, я буду искать адрес магазина по GPS, но загрузка займет, поэтому я выключу радио, чтобы я мог услышать маму лучше, затем я пойму, что забыл надеть куртку, и на улице холодно, но это неважно, продолжаю вести машину и разговаривать с мамой, а затем машину напомнит, что я не пристегнут, так что «Да, мама, я надеваю ремень безопасности всегда!». Ах, наконец, GPS загрузил маршурт...

Как бы смешно это ни звучало, но именно так наши мозги работают на функциональном уровне. Помните, что это не многозадачность, это просто быстрое переключение между контекстами.

Причина, по которой нам сложно разрабатывать асинхронный код, особенно когда все, что у нас есть, это колбеки, заключается в том, что мыслить и планировать «потоком» противоестественно для нас.

Мы думаем поэтапно, но инструменты (колбэки), доступные нам в коде, не выражаются поэтапно, как только мы переходим от синхронного к асинхронному.

И **поэтому** так сложно точно написать и проанализировать асинхронный JS-код с колбэками: потому что работа нашего мозга устроена иначе.

**Замечание**: Единственное, что хуже непонимания почему код не работает, это непонимание того, а почему он вообще работал! Это классический пример «карточного домика»: «он работает, но я не знаю почему, поэтому не трожьте его!» Возможно, вы слышали выражение: «Ад, это другие люди» (Сартр). У программистов есть своя версия: «Ад - это код других людей». Я убежден: «Ад — это непонмание своего собсивенного кода». И колбеки являются одним из главных виновников.

## Вложенные/связанные колбэки

Рассмотрим такой код:

```javascript
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );
```

У нас есть цепочка из трех вложенных функций, каждая из которых представляет шаг в асинхронной серии (задача, «процесс»).

Такой код часто называют «callback hell», а иногда даже «пирамидой обреченности» (из за бокового отступа).

Но «callback hell» фактически не имеет отношения ко вложенности или отспупам. Эта проблема гораздо более глкбокая. Дальше мы рассмотрим, что к чему.

Сначала мы ждем события «клика», затем мы ждем, когда таймер выполнится, мы ожидаем ajax-ответа, затем можем повторить все снова.

На первый взгляд, асинхронная работа этого кода кажется очевидной.

Сначала (*сейчас*):

```javascript
listen( "..", function handler(..){
	// ..
} );
```

*Потом*:

``` javascript
setTimeout( function request(..){
	// ..
}, 500) ;
```

Все еще *потом*:

```javascript
ajax( "..", function response(..){
	// ..
} );
```

Наконец еще *позже*:

```javascript
if ( .. ) {
	// ..
}
else ..
```

Есть несколько проблем, относительно линейности этого кода.

Во-первых, это случайность, что шаги выполения нашей программы выполняются ступенчато (друг за другом). Реальный код чаще всего содержит гораздо больше запутанностей и нюансов, о которых мы должны помнить, когда переходим от одной функции к другой. Понимание асинхронного потока в таком коде (с колбэками) не является чем то невозможным. Но это сложно, даже с учетом большой практики.

Но в этом коде есть нечто более *глубокое*, неочевидное. Позвольте мне предложить другой пример в виде псевдокода, чтобы проиллюстрировать свою мысль:

```javascript
doA( function(){
	doB();

	doC( function(){
		doD();
	} )

	doE();
} );

doF();
```

В то время как опытный из вас правильно определит истинный порядок операций здесь, я готов поспорить, что на первый взгляд он немного сбивает с толку и принимает некоторые согласованные ментальные циклы. Операции будут выполняться в следующем порядке:

Готов поспорить, что с первого взгляда этот код может сбить с толку. Хотя опытные разработчики, конечно, сразу поняли правильный порядок операций:

* `doA()`
* `doF()`
* `doB()`
* `doC()`
* `doE()`
* `doD()`

А вы поняли првильный порядок с первого раза?

Хорошо, некоторые из вас думают, что я специально выбрал такие имена функциё, чтобы преднамеренно ввести вас в заблуждение. Клянусь, я просто назвал порядок сверху вниз. Но давайте попробуем еще раз:

```javascript
doA( function(){
	doC();

	doD( function(){
		doF();
	} )

	doE();
} );

doB();
```

Теперь я назвал их в алфавитном порядке. Но я все еще держу пари, что для некоторых, порядрк `A -> B -> C -> D -> E ->` кажется неочевидным. Ваши глаза очень много прыгают по коду, не так ли?

Но даже, если для вас выполение этого кода очеыидно, то есть еще одна опасность. Заметили ее?

Что если, `doA(..)` или `doD(..)` на самом деле не асинхронные, как мы, очевидно, предположили? Ох, теперь порядок отличается. Если обе функции синхронные (такое возможно только в редком случае, в зависимости от условий программы), порядок будет  `A -> C -> D -> F -> E -> B`.

Тот звук который вы сейчас услышали, который вы только что слышали на заднем плане, это вздох тысяч JS-разработчиков, сделавших фейспалм.

Так проблема во вложенности? Неужели из за нее сложно следить за асинхронностью? Отчасти.

Позвольте, я перепишу наш пример, не используя вложенность:

```javascript
listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
```

Это вариант не так сложно анализировать, как предыдущий со вложенностью. Но тем не менее — это все еще «callback hell». Почему?

Когда мы переходим к последовательному анализу этого кода, мы должны переходим от одной функции до следующей, следующей и в итоге вырисовываем себе всю карту последовательности. И помните, что это упрощенный код. Мы знаем, что настоящие асинхронные JS-программны порой фантастически запутаны, что делает анализ кода на порядок сложнее.

**Еще одно замечание: чтобы последовательно связать шаги 2, 3 и 4 , единственные обратные вызовы, предоставляемые нами только по отдельности, дают нам твердое кодирование шага 2 на шаг 1, шаг 3 на шаг 2, этап 4 на этап 3, и так далее. Hardcoding не обязательно является плохим, если это действительно фиксированное условие, что шаг 2 всегда должен привести к шагу 3.**

Хардкод определенно делает код более хрупким, поскольку он не учитывает ситауции, когда что-то идет не так. Например, если шаг 2 *падает*, шаг 3 никогда не выполнится, а шаг 2 не повторится или не перейдет к альтернативному потоку обработки ошибок и т. д.

Все эти проблемы *можно* захардкодить руками, но тогда этот код нельзя будет использовать повтороно в других частях программы.

Несмотря на то, что наш мозг могжет планировать ряд задач в последовательном виде (это, затем это, а затем и это), восстановление этого процесса происходит очень легко. Наример, вы выполняете поручения, и понимаете, что оставили свой список покупок дома. Это незалпанированное событие, но оно не завершает ваш день. Ваш мозг легко исправляет эту ситуацию: вы идете домой, забираете список, а затем отправляетесь обратно в магазин.

Но хрупкий характер хардкодных колбеков (даже при запрограммированной обработке ошибок) не такой изящниый. После того, как вы закончите описывать (предугадывать) все различные варианты, код становится настолько запутанным, что его сложно будет поддерживать или обновлять.

Вот что такое «callback hell»! Вложенность / отступы - это уже вторично.

И, если кому то и этого недостаточно, то мы даже не коснулись того, что происходит, когда две или более цепочки этих колбэков выполняются одновременно или когда третий шаг разветвляется на «параллельные» колбеки с помощью «затворов» или «прищепок» ... OMG, мой мозг взорвался, как там ваш?!

Вы понимаете, что наше последовательное, блокирующее поведение в планировании мозга не согласуется с асинхронным кодом в виде колбэков? Это первый серьезный недостаток, заключающийся в том, чтобы выразить суть колбэков: они описывают асинхронность кода, в то время, как наш мозг пытается работать синхронно!

## Вопросы доверия

Давайте снова рассмотрим понятие колбека, как продолжения (ака второй половины) нашей программы:

```javascript
// A
ajax( "..", function(..){
	// C
} );
// B
```

`// A` и `// B` происходят *сейчас* под прямым управлением основной программы JS. Но выполнение  `// C` откладывается, чтобы произойти позже, и под контролем другой части — функции `ajax(..)`. Как правило такая передача контроля не вызывает много проблем для программ.

Но не стоит обманываться. Фактически такая передача контроля, это одна из худших (и в то же время самых тонких) проблем, связанных с колбеками. Она вращается вокруг идеи, что иногда `ajax(..)` (т.е. «часть», с которой вы передаете свой колбек) — это не функция, которую вы написали, или которую вы непосредственно контролируете. Чаще всего это утилита, предоставляемая третьей стороной.

Мы называем это «инверсией контроля», когда вы берете часть свеой программы и *доверяете* ее исполнение третьей стороне. Существует негласный «контракт», который существует между вашим кодом и сторонней утилитой — набор вещей, которые должны поддерживаться.

### Сказ о пяти колбэках

Важность того, что мы рассмотрели выше, может быть не столь очевидна. Позвольте мне построить фантастический сценарий, чтобы проиллюстрировать опасность *доверия*.

Представьте, что вы разработчик, которому поручено создать систему проверки электронной торговли для сайта, который продает дорогие телевизоры. У вас уже есть все различные страницы системы проверки, сделанные просто отлично. На последней странице, когда пользователь нажимает «подтвердить», чтобы купить телевизор, вам нужно вызвать стороннюю функцию (предоставленную компанией по отслеживанию аналитики), чтобы можно было отслеживать продажу.

Вы заметили, что предоставленная утилита асинхронная, возможно этьо сделано ради повышения производтельности. Это означает, что вам нужно передать колбек, чтобы в итоге получить код, который взимает деньги с кредитной карты клиента и отображает страницу с благодарностью.

Все это может выглядеть так:

```javascript
analytics.trackPurchase( purchaseData, function(){
	chargeCreditCard();
	displayThankyouPage();
} );
```

Довольно просто, правда? Вы пишете код, тестируете его, все работает, заливаете на прод. Все счастливы!

Шесть месяцев проходят без проблем. Вы почти забыли, что написали этот код. Однажды утром вы в кафе перед работой, наслаждаясь латте, получаете тревожный звонок от вашего босса, который настаивает на том, что вы бросаете кофе и сразу бросаетесь на работу.

Придя на работу , вы узнаете, что у высококлассного клиента была снята кредитная карта пять раз за тот же телевизор, и он, понятно, расстроен. Служба поддержки клиентов уже извинилась и возместила ущерб. Но ваш босс требует знать, как это могло произойти. «Разве мы не протестировали этот кейс?»

Проверив логи вы пришли к выводу, что причина заключается в том, что утилита аналитики почему-то вызвала ваш колбек пять раз вместо одного. Разумеется, в документации об этом ни слова.

Разочарованный, вы обращаетесь в службу поддержки, которая изумлена не меньше вашего. Там решают пообщаться со свомими разработчиками и ответить вам. На следующий день вы получите длинное письмо, объясняющее, что они нашли, которое вы быстро пересылаете своему боссу.

По всей видимости, разработчики аналитической компании эксперименировали с кодом, который при определенных условиях повторял вызов колбэка один раз в секунду в течение пяти секунд перед, перед уходом в таймаут. Они никогда выкативать это в прод, но случилось,то, что случилось. Они были в замешательстве и долго извинились. Они подробно описывали, как они определили сбой и что они сделают, чтобы это никогда не повторилось.

Что же дальше?

Вы обсуждаепте это с вашим боссом, но такой порядок вещей его не устраивает. Он настаивает, и вы неохотно признаете, что больше не можете доверять *им* , и вам нужно будет выяснить, как защитить код от такой уязвимости.

После копания в программе вы пишите хак на этот случай, на первый взгляд рабочий:

```javascript
var tracked = false;

analytics.trackPurchase( purchaseData, function(){
	if (!tracked) {
		tracked = true;
		chargeCreditCard();
		displayThankyouPage();
	}
} );
```
**Примечание**: Похоже на то, что мы делали в прошлой главе. По факту мы создали «защелку» для обработки случая многократного вызова колбэка.

Но затем один из ваших тестировщикок спрашивает: «Что произойдет, если колбек никогда не вызовут?» Об этом вы не подумали, к сожалению.

Вы начинаете прокручивать все возможные варианты событий, которые могут пойти не так, при вызове колбэка. Вот примерный списсок таких кейсов:

* Колбэк вызывается слишком рано (еще до начала трекинга)
* Колбэк вызывается слишком поздно (или вообще никогда)
* Колбэк вызывается слишком мало или слишком много раз (проблема с которой вы уже столкнулись!)
* Невозможно передать любую необходимую параметры для вашего колбэка
* Возникающие ошибки/исключения могут быть не обработаны
* ...

Постепенно вы начинаете понимать, что вам придется **изобретать много хаков для каждого колбэка**, передаваемого в стороннюю утилиту, которой вы уже не можете доверять.

Теперь вы понимаете, насколько адским бывает «callback hell».

## Не только чужой код

Некоторые из вас могут скептически относиться к этому вопросу. Возможно, вы вообще не используете посторонние утилиты. Возможно, вы используете версированные API или хостите собственные библиотеки.

Но ответьте мне: можете ли вы *доверять* собственным утилитам?

Большинство из нас согласятся, что для своих функций мы должны писать проверки входных параметром, тем самым страхуясь от неожиданных ситуаций.

Например, таких. Самонадеянным будет предположение, что на вход функции будут подавать только числа:

```javascript
function addNumbers(x,y) {
	// + это еще и оператор конкатенации строк
	// такая операция не может считаться безопасной,
	// так как сильно зависит от входных параметров
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// "2121"
```
Добавим проверку данных:

```javascript
function addNumbers(x,y) {
	// проверяем действительно ли аргументы это числа
	if (typeof x != "number" || typeof y != "number") {
		throw Error( "Bad parameters" );
	}

	// если проверка прошла успешно, то + выполнит именно сложение, а не конкатенацию
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// Error: "Bad parameters"
```
Или например такой вариант: более читабельный и все еще безопасный:

```javascript
function addNumbers(x,y) {
	// проверяем действительно ли аргументы это числа
	x = Number( x );
	y = Number( y );

	// + выполнит именно сложение, а не конкатенацию
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// 42
```

Это распространенная пратика делать такие проверки. Даже в том коде, которому вы доверяете. Тут работает известный политический принцип — «Доверяй, но проверяй».
