# Вы не знаете JS: Асинхронность и Производительность
# Глава 2: Колбэки

В Главе 1 мы изучили термины и концепции, связанные с асинхронным программированием на Jacascript. Мы сосредоточились на изучении работы однопоточной очереди цикла событий, которая «управляет» всеми событиями (асинхронными вызовами функций). Мы также изучали различные способы, которыми шаблоны параллелизма объясняют взаимосвязь (если она есть!) между одновременно запущенными цепочками событий или «процессами» (задачами, вызовами функций и т. д.).

Все наши примеры в Главе 1 использовали функцию, как индивидуальную, неделимую единицу операций, внутри которой выполнялись операторы в предсказуемом порядке. Однако при вызове этих функций порядок может не соблюдаться.

Во всех этих случаях функция действует как «колбэк». Всякий раз она «возвращается» в программу, при обработке этого элмента в очереди цикла событий.

Как вы, несомненно, заметили, колбеки на сегодняшний день являются наиболее распространенным способом выражения и управления асинхронностью в программах на JS. Действительно, колбэк — это самый фундаментальный асинхронный шаблон в JS.


Множество JS-программ, даже очень сложных, были написаны с использованием колбэков (разумеется, вместе с шаблонами параллелизма, которые мы исследовали в главе 1). Колбэки - это асинхронная рабочая лошадка для JavaScript, и она выполняет свою работу с достоинством.

Кроме того... колбэки не лишены недостатков. Многие разработчики в восторге от промисов — лучшего асинхронного шаблона. Но невозможно эффективно использовать абстракцию, если вы не понимать, что лежит в ее основе.

В этой главе мы рассмотрим пару таких абстракций. Это нужно для понимания необходимости использования более сложных асихронных шаблонов (они будут рассмотрены в следующих главах).

## Continuations

Вернемся к примеруколбэка, который мы начали в главе 1, но позвольте мне немного изменить его:

```javascript
// A
ajax( "..", function(..){
  // C
} );
// B
```

`//A` и `//B` представляют первую половину программы («сейчас»), часть `//C` вторую половину («потом»). Первая часть выполнится, как надо. Потом наступит пауза непонятной длины. В какой то момент, если Ajax-запрос завершится, программа продолжит выполнение с того места, где она остановилась. Вторая половина будет выполнена.

Иными словами, колбэк инкапсулирует «продолжение выполнения» программы.

Давайте еще упростим наш пример:

```javascript
// A
setTimeout( function(){
  // C
}, 1000 );
// B
```

Остановитесь на мгновение и спросите себя, как бы вы объяснили (кому-то еще менее информированному о том, как работает JS), как ведет себя эта программа. Попробуйие вслух. Это хорошее упражнение, которое поможет следующим вопросам иметь больше смысла.

Большинство читателей, вероятно, подумали или сказали что-то вроде: «Выполнится A, затем установится тайм-аут, чтобы подождать 1000 миллисекунд, а затем, когда это срабатывает, выполнится C.». Насколько верно ваше толкование?

Вы, возможно, заметили подвох и сказали: «Выполнится A, затем установится тайм-аут тайм-аут на 1000 миллисекунд, выполнится B, а затем, после того, как тайм-аут пройдет, выполнится C.». Это более точное толкование, чем первая версия. Заметили разницу?

Несмотря на то, что вторая версия более точная, обе версии недостаточно объясняют выполнение этого кода.

Как только мы вводим одно продолжение (или несколько десятков тысяч программ!) В виде функции обратного вызова, мы разрешили расхождение между тем, как работают наши мозги и как работает код. Каждый раз, когда эти двое расходятся (и это далеко не единственное место, которое, как я уверен, вы знаете!), Мы сталкиваемся с неизбежным фактом, что наш код становится сложнее понять, рассуждать, отлаживать и поддерживать.

## Sequential Brain

Я почти уверен, что большинство читателей слышали, как кто-то сказал (даже сам утверждал): «Я многозадачник». Многозадачность может проявляться по-разному — от юмористического (например, глупой игры поглаживания головы-потирания живота) до обывательского (жевать жвачку при ходьбе) или до совершенно опасного (читать будучи за рулем).

Но многозадачники ли мы? Можем ли мы на самом деле делать сразу два осознанных, преднамеренных действия и думать / рассуждать о них в один и тот же момент? Человеческий мозг имеет высшый уровень функциональности, но может ли он работать параллельно-мультипоточно?

Ответ может вас удивить: возможно, нет.


Это не так просто, разобраться в «настройках» нашего мозга. Все-таки стоит признаться, что наш мозг гораздо более «однозадачен». Мы действительно можем думать только об одном в любой момент.

Я не говорю о всех наших непроизвольных, подсознательных, автоматических функциях мозга, таких как сердцебиение, дыхание и мигание век. Все это жизненно важные задачи , но мы не управляем ими намеренно. К счастью, пока мы в 15-й раз за три минуты проверяем ленту социальных сетей, наш мозг продолжает работать в фоновом режиме (потоки!) со всеми этими важными задачами.

Вместо этого мы говорим о том, какая задача находится в нашем разуме в данный момент. Для меня это написание текста в этой книге прямо сейчас. Выполняется ли в этот момент какая-либо другая функция высокого уровня? Нет, не совсем. Я отвлекаюсь быстро и легко - несколько десятков раз в этих последних параграфах!

Возникает ощущение «ложной» многозадачности. Мы пытаемся делать разные вещи одновременно, мы разговариваем с другом или членом семьи по телефону. Другими словами, мы переключаемся вперед и назад между двумя или более задачами в быстрой последовательности, одновременно продвигаясь по каждой задаче в маленьких маленьких быстрых частях. Мы делаем это так быстро, что для внешнего мира кажется, что мы делаем это параллельно.

Это звучит так же подозрительно, как асинхронный параллелизм (вроде того, что происходит в JS)? Если нет, вернитесь и снова прочитайте главу 1!

С радостью упомяну об одной аналогии, упрощающей понимание мозговой неврологии. Наш мозг работает, как очередь цикла событий.

Набор буквы или слова можно представить, как асинхронное событие, которое может прерываться десятком других событий (например, моими чувствами или мыслями).

Я не прерываю и не прикладываю к другому «процессу» при каждой возможности, которую я мог бы (к счастью, или эта книга никогда не будет написана!). Но это случается достаточно часто, когда я чувствую, что мой собственный мозг почти постоянно переключается на различные контексты (например, «процессы»). И это очень похоже на то, как, вероятно, почувствовал бы двигатель JS.

Я не прерываюсь и не перехожу к другому «процессу» при первой возможности (и это хорошо, иначе я бы не дописал эту книгу). Но такие прерыванния случаются довольно часто, мо   мозг почти постоянно переключается на различные переключается на различные контексты (например, «процессы»).
И это очень похоже на раблту движка JS.

## Выполнение или Планирование

Хорошо, условиимся рассматривать наши мозги, как работающие в однопоточной очереди цикла событий, как в JS. Неплохое сравнение.

Однако существует большая, заметная разница между тем, как мы планируем различные задачи, и как наш мозг фактически управляют этими задачами.

Опять же, вернемся к написанию этого текста в качестве метафоры. Мой грубый ментальный план заключается в том, чтобы продолжать писать и писать, последовательно по плану, который я «набросал» в своей голове. Я не планирую никаких прерываний или другой активности при письме. Но тем не менее, мой мозг все же переключается все время.

Несмотря на то, что на операционном уровне наш мозг асинхронный, мы, похоже, планируем задачи последовательно, синхронно. «Мне нужно пойти в магазин, потом купить молока, а потом постирать белье».

Кажется, что формулировке планирования нет ничего асинхронного. На самом деле, это редкость для нас сознательно думать исключительно о событиях. Вместо этого мы планируем все тщательно, последовательно (A, затем B, затем C), и мы предполагаем своего рода временную блокировку, которая заставляет B ждать события A и C ждать события B.

Когда разработчик пишет код, он планируют выполнить ряд действий. Если это хороший разработчик, он тщательно планирует это. «Мне нужно установить `z` значение `x`, а затем `x` значение `y`» и так далее.

Когда мы пишем синхронный код, оператор за оператором, он очень похож на ToDo-лист:

```javascript
z = x;
x = y;
y = z;
```
Эти три оператора присваивания являются синхронными, а значит `x = y` ждет завершения `z = x`, и `y = z`, в свою очередь, ждет завершения `x = y`. Другой способ это указать, что эти три утверждения связаны временем с выполнением в определенном порядке, один за другим. К счастью, нам не нужно беспокоиться о каких-либо асинхронных событиях здесь. Если бы мы это сделали, код стал бы намного сложнее!

Итак, синхронное планирование мозга хорошо работает с синхронными операторами кода. Насколько хорошо наши мозг работает при планировании асинхронного кода?

Оказывается, описание асинхронности (с помощью колбэков) в нашем коде, не очень хорошо соотносится с синхронным планированием мозга.

Можете ли вы представить такую ситуацию?

Мне нужно пойти в магазин, но по дороге я уверен, что мне позвонят, так что «Привет, мам», и когда она заговорит, я буду искать адрес магазина по GPS, но загрузка займет, поэтому я выключу радио, чтобы я мог услышать маму лучше, затем я пойму, что забыл надеть куртку, и на улице холодно, но это неважно, продолжаю вести машину и разговаривать с мамой, а затем машину напомнит, что я не пристегнут, так что «Да, мама, я надеваю ремень безопасности всегда!». Ах, наконец, GPS загрузил маршурт...

Как бы смешно это ни звучало, но именно так наши мозги работают на функциональном уровне. Помните, что это не многозадачность, это просто быстрое переключение между контекстами.
