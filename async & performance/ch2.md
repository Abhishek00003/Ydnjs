# Вы не знаете JS: Асинхронность и Производительность
# Глава 2: Колбэки

В Главе 1 мы изучили термины и концепции, связанные с асинхронным программированием на Javascript. Мы сосредоточились на изучении работы однопоточной очереди цикла событий, которая «управляет» всеми событиями (асинхронными вызовами функций). Мы также изучали различные способы, которыми шаблоны параллелизма объясняют взаимосвязь (если она есть!) между одновременно запущенными цепочками событий или «процессами» (задачами, вызовами функций и т. д.).

Все наши примеры в Главе 1 использовали функцию, как индивидуальную, неделимую единицу операций, внутри которой выполнялись операторы в предсказуемом порядке. Однако при вызове этих функций порядок может не соблюдаться.

Во всех этих случаях функция действует как «колбэк». Всякий раз она «возвращается» в программу, при обработке этого элемента в очереди цикла событий.

Как вы, несомненно, заметили, колбэки на сегодняшний день являются наиболее распространенным способом выражения и управления асинхронностью в программах на JS. Действительно, колбэк — это самый фундаментальный асинхронный шаблон в JS.


Множество JS-программ, даже очень сложных, были написаны с использованием колбэков (разумеется, вместе с шаблонами параллелизма, которые мы исследовали в главе 1). Колбэки - это асинхронная рабочая лошадка для JavaScript, и она выполняет свою работу с достоинством.

Кроме того... колбэки не лишены недостатков. Многие разработчики в восторге от промисов — лучшего асинхронного шаблона. Но невозможно эффективно использовать абстракцию, если вы не понимать, какие механизмы лежат в ее основе.

В этой главе мы рассмотрим несколько таких механизмов. Это нужно для понимания необходимости использования более сложных асинхронных шаблонов (они будут рассмотрены в следующих главах).

## Продолжения

Вернемся к примеру колбэка, который мы начали в главе 1, но позвольте мне немного изменить его:

```javascript
// A
ajax( "..", function(..){
  // C
} );
// B
```

`//A` и `//B` представляют первую половину программы («сейчас»), часть `//C` вторую половину («потом»). Первая часть выполнится, как надо. Потом наступит пауза непонятной длины. В какой то момент, если Ajax-запрос завершится, программа продолжит выполнение с того места, где она остановилась. Вторая половина будет выполнена.

Иными словами, колбэк инкапсулирует «продолжение выполнения» программы.

Давайте еще упростим наш пример:

```javascript
// A
setTimeout( function(){
  // C
}, 1000 );
// B
```

Остановитесь на мгновение и спросите себя, как бы вы объяснили (кому-то еще менее информированному о том, как работает JS), как ведет себя эта программа. Попробуйте вслух. Это хорошее упражнение, которое поможет следующим вопросам иметь больше смысла.

Большинство читателей, вероятно, подумали или сказали что-то вроде: «Выполнится A, затем установится тайм-аут, чтобы подождать 1000 миллисекунд, а затем, когда это срабатывает, выполнится C.». Насколько верно ваше толкование?

Вы, возможно, заметили подвох и сказали: «Выполнится A, затем установится тайм-аут тайм-аут на 1000 миллисекунд, выполнится B, а затем, после того, как тайм-аут пройдет, выполнится C.». Это более точное толкование, чем первая версия. Заметили разницу?

Несмотря на то, что вторая версия более точная, обе версии недостаточно объясняют выполнение этого кода.

Как только мы вводим одно продолжение (или несколько десятков тысяч программ!) В виде функции обратного вызова, мы разрешили расхождение между тем, как работают наши мозги и как работает код. Каждый раз, когда эти двое расходятся (и это далеко не единственное место, которое, как я уверен, вы знаете!), Мы сталкиваемся с неизбежным фактом, что наш код становится сложнее понять, рассуждать, отлаживать и поддерживать.

## Последовательное мышление

Я почти уверен, что большинство читателей слышали, как кто-то сказал (или даже сам утверждал): «Я — многозадачник». Многозадачность может проявляться по-разному — от юмористического (например, глупой игры поглаживания головы-потирания живота) до обывательского (жевать жвачку при ходьбе) или до совершенно опасного (читать будучи за рулем).

Но многозадачники ли мы? Можем ли мы на самом деле делать сразу два осознанных, преднамеренных действия и думать / рассуждать о них в один и тот же момент? Человеческий мозг имеет высший уровень функциональности, но может ли он работать параллельно-мультипоточно?

Ответ может вас удивить: возможно, нет.


Это не так просто, разобраться в «настройках» нашего мозга. Все-таки стоит признаться, что наш мозг гораздо более «однозадачный». Мы действительно можем думать только об одном в любой момент.

Я не говорю о всех наших непроизвольных, подсознательных, автоматических функциях мозга, таких как сердцебиение, дыхание и мигание век. Все это жизненно важные задачи , но мы не управляем ими намеренно. К счастью, пока мы в 15-й раз за три минуты проверяем ленту социальных сетей, наш мозг продолжает работать в фоновом режиме (потоки!) со всеми этими важными задачами.

Вместо этого мы говорим о том, какая задача находится в нашем разуме в данный момент. Для меня это написание текста в этой книге прямо сейчас. Выполняется ли в этот момент какая-либо другая функция высокого уровня? Нет, не совсем. Я отвлекаюсь быстро и легко - несколько десятков раз в этих последних параграфах!

Возникает ощущение «ложной» многозадачности. Мы пытаемся делать разные вещи одновременно, мы разговариваем с другом или членом семьи по телефону. Другими словами, мы переключаемся вперед и назад между двумя или более задачами в быстрой последовательности, одновременно продвигаясь по каждой задаче в маленьких маленьких быстрых частях. Мы делаем это так быстро, что для внешнего мира кажется, что мы делаем это параллельно.

Это звучит так же подозрительно, как асинхронный параллелизм (вроде того, что происходит в JS)? Если нет, вернитесь и снова прочитайте главу 1!

С радостью упомяну об одной аналогии, упрощающей понимание мозговой неврологии. Наш мозг работает, как очередь цикла событий.

Набор буквы или слова можно представить, как асинхронное событие, которое может прерываться десятком других событий (например, моими чувствами или мыслями).

Я не прерываюсь и не перехожу к другому «процессу» при первой возможности (и это хорошо, иначе я бы не дописал эту книгу). Но такие прерывания случаются довольно часто, мой мозг почти постоянно переключается на различные переключается на различные контексты (например, «процессы»).
И это очень похоже на работу движка JS.

## Выполнение или Планирование

Хорошо, условимся рассматривать наш мозг, как работающий в однопоточной очереди цикла событий, как в JS. Неплохое сравнение.

Однако существует большая, заметная разница между тем, как мы планируем различные задачи, и как наш мозг фактически управляют этими задачами.

Опять же, вернемся к написанию этого текста в качестве метафоры. Мой грубый ментальный план заключается в том, чтобы продолжать писать и писать, последовательно по плану, который я «набросал» в своей голове. Я не планирую никаких прерываний или другой активности при письме. Но тем не менее, мой мозг все же переключается все время.

Несмотря на то, что на операционном уровне наш мозг асинхронный, мы, похоже, планируем задачи последовательно, синхронно. «Мне нужно пойти в магазин, потом купить молока, а потом постирать белье».

Кажется, что формулировке планирования нет ничего асинхронного. На самом деле, это редкость для нас сознательно думать исключительно о событиях. Вместо этого мы планируем все тщательно, последовательно (A, затем B, затем C), и мы предполагаем своего рода временную блокировку, которая заставляет B ждать события A и C ждать события B.

Когда разработчик пишет код, он планируют выполнить ряд действий. Если это хороший разработчик, он тщательно планирует это. «Мне нужно установить `z` значение `x`, а затем `x` значение `y`» и так далее.

Когда мы пишем синхронный код, оператор за оператором, он очень похож на ToDo-лист:

```javascript
z = x;
x = y;
y = z;
```
Эти три оператора присваивания являются синхронными, а значит `x = y` ждет завершения `z = x`, и `y = z`, в свою очередь, ждет завершения `x = y`. Другой способ это указать, что эти три утверждения связаны временем с выполнением в определенном порядке, один за другим. К счастью, нам не нужно беспокоиться о каких-либо асинхронных событиях здесь. Если бы мы это сделали, код стал бы намного сложнее!

Итак, синхронное планирование мозга хорошо работает с синхронными операторами кода. Насколько хорошо наши мозг работает при планировании асинхронного кода?

Оказывается, описание асинхронности (с помощью колбэков) в нашем коде, не очень хорошо соотносится с синхронным планированием мозга.

Можете ли вы представить такую ситуацию?

Мне нужно пойти в магазин, но по дороге я уверен, что мне позвонят, так что «Привет, мам», и когда она заговорит, я буду искать адрес магазина по GPS, но загрузка займет, поэтому я выключу радио, чтобы я мог услышать маму лучше, затем я пойму, что забыл надеть куртку, и на улице холодно, но это неважно, продолжаю вести машину и разговаривать с мамой, а затем машину напомнит, что я не пристегнут, так что «Да, мама, я надеваю ремень безопасности всегда!». Ах, наконец, GPS загрузил маршрут...

Как бы смешно это ни звучало, но именно так наши мозги работают на функциональном уровне. Помните, что это не многозадачность, это просто быстрое переключение между контекстами.

Причина, по которой нам сложно разрабатывать асинхронный код, особенно когда все, что у нас есть, это колбэки, заключается в том, что мыслить и планировать «потоком» противоестественно для нас.

Мы думаем поэтапно, но инструменты (колбэки), доступные нам в коде, не выражаются поэтапно, как только мы переходим от синхронного к асинхронному.

И **поэтому** так сложно точно написать и проанализировать асинхронный JS-код с колбэками: потому что работа нашего мозга устроена иначе.

**Замечание**: Единственное, что хуже непонимания почему код не работает, это непонимание того, а почему он вообще работал! Это классический пример «карточного домика»: «он стоит, но я не знаю почему, поэтому не трогайте его!» Возможно, вы слышали выражение: «Ад — это другие люди» (Сартр). У программистов есть своя версия: «Ад — это код других людей». Я убежден: «Ад — это непонимание своего собственного кода». И колбэки являются одними из главных виновников.

## Вложенные/связанные колбэки

Рассмотрим такой код:

```javascript
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );
```

У нас есть цепочка из трех вложенных функций, каждая из которых представляет шаг в асинхронной серии (задача, «процесс»).

Такой код часто называют «callback hell», а иногда даже «пирамидой обреченности» (из за бокового отступа).

Но «callback hell» фактически не имеет отношения ко вложенности или отступам. Эта проблема гораздо более глубокая. Дальше мы рассмотрим, что к чему.

Сначала мы ждем события «клика», затем мы ждем, когда таймер выполнится, мы ожидаем ajax-ответа, затем можем повторить все снова.

На первый взгляд, асинхронная работа этого кода кажется очевидной.

Сначала (*сейчас*):

```javascript
listen( "..", function handler(..){
	// ..
} );
```

*Потом*:

``` javascript
setTimeout( function request(..){
	// ..
}, 500) ;
```

Все еще *потом*:

```javascript
ajax( "..", function response(..){
	// ..
} );
```

Наконец еще *позже*:

```javascript
if ( .. ) {
	// ..
}
else ..
```

Есть несколько проблем, относительно линейности этого кода.

Во-первых, это случайность, что шаги выполнения нашей программы выполняются ступенчато (друг за другом). Реальный код чаще всего содержит гораздо больше запутанностей и нюансов, о которых мы должны помнить, когда переходим от одной функции к другой. Понимание асинхронного потока в таком коде (с колбэками) не является чем то невозможным. Но это сложно, даже с учетом большой практики.

Но в этом коде есть нечто более *глубокое*, неочевидное. Позвольте мне предложить другой пример в виде псевдокода, чтобы проиллюстрировать свою мысль:

```javascript
doA( function(){
	doB();

	doC( function(){
		doD();
	} )

	doE();
} );

doF();
```

В то время как опытный из вас правильно определит истинный порядок операций здесь, я готов поспорить, что на первый взгляд он немного сбивает с толку и принимает некоторые согласованные ментальные циклы. Операции будут выполняться в следующем порядке:

Готов поспорить, что с первого взгляда этот код может сбить с толку. Хотя опытные разработчики, конечно, сразу поняли правильный порядок операций:

* `doA()`
* `doF()`
* `doB()`
* `doC()`
* `doE()`
* `doD()`

А вы поняли правильный порядок с первого раза?

Хорошо, некоторые из вас думают, что я специально выбрал такие имена функций, чтобы преднамеренно ввести вас в заблуждение. Клянусь, я просто назвал порядок сверху вниз. Но давайте попробуем еще раз:

```javascript
doA( function(){
	doC();

	doD( function(){
		doF();
	} )

	doE();
} );

doB();
```

Теперь я назвал их в алфавитном порядке. Но я все еще держу пари, что для некоторых, порядок `A -> B -> C -> D -> E ->` кажется неочевидным. Ваши глаза очень много прыгают по коду, не так ли?

Но даже, если для вас выполнение этого кода очевидно, то есть еще одна опасность. Заметили ее?

Что если, `doA(..)` или `doD(..)` на самом деле не асинхронные, как мы, очевидно, предположили? Ох, теперь порядок отличается. Если обе функции синхронные (такое возможно только в редком случае, в зависимости от условий программы), порядок будет  `A -> C -> D -> F -> E -> B`.

Тот звук который вы сейчас услышали, который вы только что слышали на заднем плане, это вздох тысяч JS-разработчиков, сделавших фейспалм.

Так проблема во вложенности? Неужели из за нее сложно следить за асинхронностью? Отчасти.

Позвольте, я перепишу наш пример, не используя вложенность:

```javascript
listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
```

Это вариант не так сложно анализировать, как предыдущий со вложенностью. Но тем не менее — это все еще «callback hell». Почему?

Когда мы переходим к последовательному анализу этого кода, мы должны переходим от одной функции до следующей, следующей и в итоге вырисовываем себе всю карту последовательности. И помните, что это упрощенный код. Мы знаем, что настоящие асинхронные JS-программны порой фантастически запутаны, что делает анализ кода на порядок сложнее.

Хардкод определенно делает код более хрупким, поскольку он не учитывает ситуации, когда что-то идет не так. Например, если шаг 2 *падает*, шаг 3 никогда не выполнится, а шаг 2 не повторится или не перейдет к альтернативному потоку обработки ошибок и т. д.

Все эти проблемы *можно* захардкодить руками, но тогда этот код нельзя будет использовать повторно в других частях программы.

Несмотря на то, что наш мозг может планировать ряд задач в последовательном виде (это, затем это, а затем и это), восстановление этого процесса происходит очень легко. Например, вы выполняете поручения, и понимаете, что оставили свой список покупок дома. Это незапланированное событие, но ведь оно не завершает ваш день. Ваш мозг легко исправляет эту ситуацию: вы идете домой, забираете список, а затем отправляетесь обратно в магазин.

Но хрупкий характер хардкодных колбеков (даже при описанной обработке ошибок) не такой изящный. После того, как вы закончите описывать (предугадывать) все различные варианты, код становится настолько запутанным, что его сложно будет поддерживать или обновлять.

Вот что такое «callback hell»! Вложенность / отступы - это уже вторично.

И, если кому то и этого недостаточно, то мы даже не коснулись того, что происходит, когда две или более цепочки этих колбэков выполняются одновременно или когда третий шаг разветвляется на «параллельные» колбэки с помощью «затворов» или «прищепок» ... OMG, мой мозг взорвался, как там ваш?!

Вы понимаете, что наше последовательное, блокирующее поведение в планировании мозга не согласуется с асинхронным кодом в виде колбэков? Это первый серьезный недостаток, заключающийся в том, чтобы выразить суть колбэков: они описывают асинхронность кода, в то время, как наш мозг пытается работать синхронно!

## Проблемы доверия

Давайте снова рассмотрим понятие колбэка, как продолжения (а.к.а второй половины) нашей программы:

```javascript
// A
ajax( "..", function(..){
	// C
} );
// B
```

`// A` и `// B` происходят *сейчас* под прямым управлением основной программы JS. Но выполнение  `// C` откладывается, чтобы произойти позже, и под контролем другой части — функции `ajax(..)`. Как правило такая передача контроля не вызывает много проблем для программ.

Но не стоит обманываться. Фактически, такая передача контроля, это одна из худших (и в то же время самых тонких) проблем, связанных с колбэками. Она вращается вокруг идеи, что иногда `ajax(..)` (т.е. «часть», с которой вы передаете свой колбэк) — это не функция, которую вы написали, или которую вы непосредственно контролируете. Чаще всего — это утилита, предоставляемая третьей стороной.

Мы называем это «инверсией контроля», когда вы берете часть своей программы и *доверяете* ее исполнение третьей стороне. Существует негласный «контракт», который существует между вашим кодом и сторонней утилитой — набор вещей, которые должны поддерживаться.

### Сказ о пяти колбэках

Важность того, что мы рассмотрели выше, может быть не столь очевидна. Позвольте мне показать выдуманный сценарий, чтобы проиллюстрировать опасность *доверия*.

Представьте, что вы разработчик, которому поручено создать систему проверки электронной торговли для сайта, который продает дорогие телевизоры. У вас уже есть все различные страницы системы проверки, сделанные просто отлично. На последней странице, когда пользователь нажимает «подтвердить», чтобы купить телевизор, вам нужно вызвать стороннюю функцию (предоставленную компанией по отслеживанию аналитики), чтобы можно было отслеживать продажу.

Вы заметили, что предоставленная утилита асинхронная, возможно это сделано ради повышения производительности. Это означает, что вам нужно передать колбэк, чтобы в итоге получить код, который взимает деньги с кредитной карты клиента и отображает страницу с благодарностью.

Все это может выглядеть так:

```javascript
analytics.trackPurchase( purchaseData, function(){
	chargeCreditCard();
	displayThankyouPage();
} );
```

Довольно просто, правда? Вы пишете код, тестируете его, все работает, заливаете на прод. Все счастливы!

Шесть месяцев проходят без проблем. Вы почти забыли, что написали этот код. Однажды утром вы в кафе перед работой, наслаждаясь латте, получаете тревожный звонок от вашего босса, который настаивает на том, что вы бросаете кофе и сразу бросаетесь на работу.

Придя на работу , вы узнаете, что у высококлассного клиента была снята кредитная карта пять раз за тот же телевизор, и он, понятно, расстроен. Служба поддержки клиентов уже извинилась и возместила ущерб. Но ваш босс требует знать, как это могло произойти. «Разве мы не протестировали этот кейс?»

Проверив логи вы пришли к выводу, что причина заключается в том, что утилита аналитики почему-то вызвала ваш колбэк пять раз вместо одного. Разумеется, в документации об этом ни слова.

Разочарованный, вы обращаетесь в службу поддержки, которая изумлена не меньше вашего. Там решают пообщаться со своимми разработчиками и ответить вам. На следующий день вы получите длинное письмо, объясняющее, что они нашли, которое вы быстро пересылаете своему боссу.

По всей видимости, разработчики аналитической компании экспериментировали с кодом, который при определенных условиях повторял вызов колбэка один раз в секунду в течение пяти секунд перед, перед уходом в таймаут. Они не собирались выкатывать это в прод, но случилось,то, что случилось. Они были в замешательстве и долго извинялись. Они подробно описывали, как они определили сбой и что они сделают, чтобы это никогда не повторилось.

Что же дальше?

Вы обсуждаете это с вашим боссом, но такой порядок вещей его не устраивает. Он настаивает, и вы неохотно признаете, что больше не можете доверять *им* , и вам нужно будет выяснить, как защитить код от такой уязвимости.

После копания в программе вы пишите хак на этот случай, на первый взгляд рабочий:

```javascript
var tracked = false;

analytics.trackPurchase( purchaseData, function(){
	if (!tracked) {
		tracked = true;
		chargeCreditCard();
		displayThankyouPage();
	}
} );
```
**Примечание**: Похоже на то, что мы делали в прошлой главе. По факту мы создали «защелку» для обработки случая многократного вызова колбэка.

Но затем один из ваших тестировщиков спрашивает: «Что произойдет, если колбек никогда не вызовется?» Об этом вы не подумали, к сожалению.

Вы начинаете прокручивать все возможные варианты событий, которые могут пойти не так, при вызове колбэка. Вот примерный списсок таких кейсов:

* Колбэк вызывается слишком рано (еще до начала трекинга)
* Колбэк вызывается слишком поздно (или вообще никогда)
* Колбэк вызывается слишком мало или слишком много раз (проблема с которой вы уже столкнулись!)
* Невозможно передать любую необходимую параметры для вашего колбэка
* Возникающие ошибки/исключения могут быть не обработаны
* ...

Постепенно вы начинаете понимать, что вам придется **изобретать много хаков для каждого колбэка**, передаваемого в стороннюю утилиту, которой вы уже не можете доверять.

Теперь вы понимаете, насколько адским бывает «callback hell».

## Не только чужой код

Некоторые из вас могут скептически относиться к этому вопросу. Возможно, вы вообще не используете посторонние утилиты. Возможно, вы используете версионные API или хостите собственные библиотеки.

Но ответьте мне: можете ли вы *доверять* собственным утилитам?

Большинство из нас согласятся, что для своих функций мы должны писать проверки входных параметром, тем самым страхуясь от неожиданных ситуаций.

Например, таких. Самонадеянным будет предположение, что на вход функции будут подавать только числа:

```javascript
function addNumbers(x,y) {
	// + это еще и оператор конкатенации строк
	// такая операция не может считаться безопасной,
	// так как сильно зависит от входных параметров
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// "2121"
```
Добавим проверку данных:

```javascript
function addNumbers(x,y) {
	// проверяем действительно ли аргументы это числа
	if (typeof x != "number" || typeof y != "number") {
		throw Error( "Bad parameters" );
	}

	// если проверка прошла успешно, то + выполнит именно сложение, а не конкатенацию
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// Error: "Bad parameters"
```
Или например такой вариант: более читабельный и все еще безопасный:

```javascript
function addNumbers(x,y) {
	// проверяем действительно ли аргументы это числа
	x = Number( x );
	y = Number( y );

	// + выполнит именно сложение, а не конкатенацию
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// 42
```

Это распространенная практика делать такие проверки. Даже в том коде, которому вы доверяете. Тут работает известный политический принцип — «Доверяй, но проверяй».

Разве не стоит делать такие проверки и для асинхронных колбэков? **Конечно, стоит.**

Но колбэки не предоставляют нам никаких инструментов для управления собой. Мы должны реализовывать их самостоятельно, и часто это заканчивается тем, что мы используем готовые шаблоны, повторяемые для каждого асинхронного колбэка.

Если у вас есть код, использующий колбэки, в том числе и с помощью сторонних утилит, и вы не написали защиту от инверсии контроля, то ваш код заражен прямо сейчас! Хотя симптомы еще не проявились.

Действительно, ад.

## Попытка сохранить коллбеки

Существует несколько вариантов дизайна колбэков, которые пытались решить некоторые (не все!) проблемы, которые мы только что рассмотрели. Это доблестная, но обреченная попытка сохранить шаблон колбэков от самоуничтожения.

Например, продвинутая обработка результатов с помощью отдельных колбэков (один для уведомления об успешном завершении, один для уведомления об ошибке):

```javascript
function success(data) {
	console.log( data );
}

function failure(err) {
	console.error( err );
}

ajax( "http://some.url.1", success, failure );
```

В API этого варианта часто обработчик ошибок `failure()` является необязательным, и если не указано, предполагается, что ошибки будут пропускаться. Непорядок.

**Примечание**: Вариант с раздельными колбэками используют ES6 Промисы. Мы рассмотрим их более подробно в следующей главе.

Другой распространенный шаблон колбэком  называется «error-first стиль» (иногда называемый «стиль Node», поскольку его использует большинство API-интерфейсов Node.js), где первый аргумент одного колбэка зарезервирован для объекта ошибок (если таковые имеются). В случае успеха, этот аргумент будет пустым / ложным (и любые последующие аргументы будут данными успешной обработки), но если ошибка все же произошла, то аргумент становится истинным, и далее ничего не происходит:

```javascript
function response(err,data) {
	// ошибка?
	if (err) {
		console.error( err );
	}
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", response );
```

В обоих случаях следует обратить внимание на некоторые вещи:

Во-первых, на самом деле он не решает большинство «проблем доверия». В колбэке нет ничего, что предотвращает или фильтрует нежелательные повторные вызовы. Более того, сейчас все еще хуже. Потому что вы можете получить как сигналы успеха, так и ошибки, или ни того, ни другого, и вам все равно придется обрабатывать любое из этих условий.

Кроме того, не упускайте тот факт, что, хотя это стандартный шаблон, он определенно не годится для повторного использования в другом месте. Вы устанете писать его для **каждого** отдельного колбэка в приложении.

Как насчет проблемы — « колбэк не был вызван»?  Вам, вероятно, потребуется настроить таймаут, который отменяет событие. Вы могли бы написать утилиту (в качестве доказательства концепции):

```javascript
function timeoutify(fn,delay) {
	var intv = setTimeout( function(){
			intv = null;
			fn( new Error( "Timeout!" ) );
		}, delay )
	;

	return function() {
		// таймаут еще не наступил?
		if (intv) {
			clearTimeout( intv );
			fn.apply( this, [ null ].concat( [].slice.call( arguments ) ) );
		}
	};
}
```

Используем её здесь:

``` javascript
// используем "error-first style"
function foo(err,data) {
	if (err) {
		console.error( err );
	}
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", timeoutify( foo, 500 ) );
```

Другой проблема в вызове колбэка «слишком рано». Это может означать вызов до того, как будет завершена какая-то критическая задача. Но в целом проблема наиболее проявляется в утилитах, которые могут либо вызвать колбэк *сейчас* (синхронно), либо *позже* (асинхронно).

Такая неопределенность почти всегда приводит к очень сложному дебаггингу. В некоторых кругах придумали монстра, вызывающего безумие, по имени Залго. Его используют для описания кошмаров синхронности/асинхронности. «Не выпускай Залго!» часто можно услышать, и это очень хороший совет: всегда вызывайте колбэки асинхронно, даже, если его выполнение придется на следующий «тик» цикла событий.

**Примечание**: Более подробно о Залго можно почитать [здесь](https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md) и [здесь](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).

Рассмотрим код:

```javascript
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", result );
a++;
```

Что мы получим в консоли? `0` — синхронный вызов или `1` — асинхронный вызов? Зависит... от условий.

Вы можете видеть, насколько быстро непредсказуемость Zalgo может угрожать любой программе на JS. Таким образом, глупо звучащее «никогда не выпускай Zalgo» на самом деле распространенный и полезный совет. Только асинхронность!

Что делать, если вы не знаете, будет ли API всегда выполняться асинхронно? Вы могли бы придумать такую утилиту, как `asyncify(..)`:

```javascript
function asyncify(fn) {
	var orig_fn = fn,
		intv = setTimeout( function(){
			intv = null;
			if (fn) fn();
		}, 0 )
	;

	fn = null;

	return function() {
		if (intv) {
			fn = orig_fn.bind.apply(
				orig_fn,
				[this].concat( [].slice.call( arguments ) )
			);
		}
		else {
			orig_fn.apply( this, arguments );
		}
	};
}
```

И использовать ее так:

```javascript
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", asyncify( result ) );
a++;
```
Независимо от того закешировался ли запрос и сразу вызвал колбэк или был сделан запрос и колбэк вызвался позже (асинхронно), этот код всегда будет выводить `1` вместо `0`. `result(..)` вызывается асинхронно, что означает, что `a++` имеет шанс запустить до `result(..)`.

Да, еще одна проблема решена! Но это неэффективное решение, и оно «раздует» ваше приложение еще сильнее.

Колбэки могут делать все, что угодно, но вы должны приложить много усилий, чтобы добиться этого. И часто это усилия требуют гораздо больше времени, чем задача которую этот колбэк выполняет.

Вы можете использовать встроенное API или другую языковую механику для решения этих проблем. Наконец, настала эра ES6, которая предлагает отличные решения, поэтому продолжайте читать дальше!

## Итоги

Обратные вызовы являются основной единицей асинхронности в JS. Но их недостаточно для эволюционирующего асинхронного программирования.

Во-первых, наши мозги планируют вещи по последовательному, блокирующему, однопоточному пути, но колбэки выражают асинхронный поток нелинейно, неестественно для нас, что значительно усложняет анализ такого кода.

Нам нужен способ выразить асинхронность в более синхронной, манере, более привычной для нашего мозга.

Во-вторых, и, что более важно, колбэки страдают от инверсии контроля. Это заключается в неявной передаче контроля над другой частью (часто с помощью сторонней утилиты), для продолжения вашей программы. Эта передача контроля приводит нас к тревожному списку проблем, например, вызывается ли колбэк чаще, чем мы ожидаем.

Написание хаков для решения этих проблем доверия возможно, но это сложнее, код становится неподдерживаемым. Также хаки не дают гарантированной защиты от неявных ошибок.

Нам нужно единое решение всех проблем доверия, которое может быть повторно использовано для любого количества колбэков, без дополнительных «костылей» к приложению.

Нам нужно что-то лучше колбэков. Они верно нам служили, но будущее Javascript требует более сложных асинхронных решений. Последующие главы этой книги будут посвящены передовым решениям в области асинхронного программирования.
