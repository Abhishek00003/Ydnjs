# Вы не знаете JS: Асинхронность и Производительность
# Глава 2: Колбэки

В Главе 1 мы изучили термины и концепции, связанные с асинхронным программированием на Jacascript. Мы сосредоточились на изучении работы однопоточной очереди цикла событий, которая «управляет» всеми событиями (асинхронными вызовами функций). Мы также изучали различные способы, которыми шаблоны параллелизма объясняют взаимосвязь (если она есть!) между одновременно запущенными цепочками событий или «процессами» (задачами, вызовами функций и т. д.).

Все наши примеры в Главе 1 использовали функцию, как индивидуальную, неделимую единицу операций, внутри которой выполнялись операторы в предсказуемом порядке. Однако при вызове этих функций порядок может не соблюдаться.

Во всех этих случаях функция действует как «колбэк». Всякий раз она «возвращается» в программу, при обработке этого элмента в очереди цикла событий.

Как вы, несомненно, заметили, колбеки на сегодняшний день являются наиболее распространенным способом выражения и управления асинхронностью в программах на JS. Действительно, колбэк — это самый фундаментальный асинхронный шаблон в JS.


Множество JS-программ, даже очень сложных, были написаны с использованием колбэков (разумеется, вместе с шаблонами параллелизма, которые мы исследовали в главе 1). Колбэки - это асинхронная рабочая лошадка для JavaScript, и она выполняет свою работу с достоинством.

Кроме того... колбэки не лишены недостатков. Многие разработчики в восторге от промисов — лучшего асинхронного шаблона. Но невозможно эффективно использовать абстракцию, если вы не понимать, что лежит в ее основе.

В этой главе мы рассмотрим пару таких абстракций. Это нужно для понимания необходимости использования более сложных асихронных шаблонов (они будут рассмотрены в следующих главах).

## Continuations

Вернемся к примеруколбэка, который мы начали в главе 1, но позвольте мне немного изменить его:

```javascript
// A
ajax( "..", function(..){
  // C
} );
// B
```

`//A` и `//B` представляют первую половину программы («сейчас»), часть `//C` вторую половину («потом»). Первая часть выполнится, как надо. Потом наступит пауза непонятной длины. В какой то момент, если Ajax-запрос завершится, программа продолжит выполнение с того места, где она остановилась. Вторая половина будет выполнена.

Иными словами, колбэк инкапсулирует «продолжение выполнения» программы.

Давайте еще упростим наш пример:

```javascript
// A
setTimeout( function(){
  // C
}, 1000 );
// B
```

Остановитесь на мгновение и спросите себя, как бы вы объяснили (кому-то еще менее информированному о том, как работает JS), как ведет себя эта программа. Попробуйие вслух. Это хорошее упражнение, которое поможет следующим вопросам иметь больше смысла.

Большинство читателей, вероятно, подумали или сказали что-то вроде: «Выполнится A, затем установится тайм-аут, чтобы подождать 1000 миллисекунд, а затем, когда это срабатывает, выполнится C.». Насколько верно ваше толкование?

Вы, возможно, заметили подвох и сказали: «Выполнится A, затем установится тайм-аут тайм-аут на 1000 миллисекунд, выполнится B, а затем, после того, как тайм-аут пройдет, выполнится C.». Это более точное толкование, чем первая версия. Заметили разницу?

Несмотря на то, что вторая версия более точная, обе версии недостаточно объясняют выполнение этого кода.

Как только мы вводим одно продолжение (или несколько десятков тысяч программ!) В виде функции обратного вызова, мы разрешили расхождение между тем, как работают наши мозги и как работает код. Каждый раз, когда эти двое расходятся (и это далеко не единственное место, которое, как я уверен, вы знаете!), Мы сталкиваемся с неизбежным фактом, что наш код становится сложнее понять, рассуждать, отлаживать и поддерживать.

## Sequential Brain

Я почти уверен, что большинство читателей слышали, как кто-то сказал (даже сам утверждал): «Я многозадачник». Многозадачность может проявляться по-разному — от юмористического (например, глупой игры поглаживания головы-потирания живота) до обывательского (жевать жвачку при ходьбе) или до совершенно опасного (читать будучи за рулем).

Но многозадачники ли мы? Можем ли мы на самом деле делать сразу два осознанных, преднамеренных действия и думать / рассуждать о них в один и тот же момент? Человеческий мозг имеет высшый уровень функциональности, но может ли он работать параллельно-мультипоточно?

Ответ может вас удивить: возможно, нет.


Это не так просто, разобраться в «настройках» нашего мозга. Все-таки стоит признаться, что наш мозг гораздо более «однозадачен». Мы действительно можем думать только об одном в любой момент.

Я не говорю о всех наших непроизвольных, подсознательных, автоматических функциях мозга, таких как сердцебиение, дыхание и мигание век. Все это жизненно важные задачи , но мы не управляем ими намеренно. К счастью, пока мы в 15-й раз за три минуты проверяем ленту социальных сетей, наш мозг продолжает работать в фоновом режиме (потоки!) со всеми этими важными задачами.

Вместо этого мы говорим о том, какая задача находится в нашем разуме в данный момент. Для меня это написание текста в этой книге прямо сейчас. Выполняется ли в этот момент какая-либо другая функция высокого уровня? Нет, не совсем. Я отвлекаюсь быстро и легко - несколько десятков раз в этих последних параграфах!

Возникает ощущение «ложной» многозадачности. Мы пытаемся делать разные вещи одновременно, мы разговариваем с другом или членом семьи по телефону. Другими словами, мы переключаемся вперед и назад между двумя или более задачами в быстрой последовательности, одновременно продвигаясь по каждой задаче в маленьких маленьких быстрых частях. Мы делаем это так быстро, что для внешнего мира кажется, что мы делаем это параллельно.

Это звучит так же подозрительно, как асинхронный параллелизм (вроде того, что происходит в JS)? Если нет, вернитесь и снова прочитайте главу 1!

С радостью упомяну об одной аналогии, упрощающей понимание мозговой неврологии. Наш мозг работает, как очередь цикла событий.

Набор буквы или слова можно представить, как асинхронное событие, которое может прерываться десятком других событий (например, моими чувствами или мыслями).

Я не прерываю и не прикладываю к другому «процессу» при каждой возможности, которую я мог бы (к счастью, или эта книга никогда не будет написана!). Но это случается достаточно часто, когда я чувствую, что мой собственный мозг почти постоянно переключается на различные контексты (например, «процессы»). И это очень похоже на то, как, вероятно, почувствовал бы двигатель JS.

Я не прерываюсь и не перехожу к другому «процессу» при первой возможности (и это хорошо, иначе я бы не дописал эту книгу). Но такие прерыванния случаются довольно часто, мо   мозг почти постоянно переключается на различные переключается на различные контексты (например, «процессы»).
И это очень похоже на раблту движка JS.

## Выполнение или Планирование

Хорошо, условиимся рассматривать наши мозги, как работающие в однопоточной очереди цикла событий, как в JS. Неплохое сравнение.

Однако существует большая, заметная разница между тем, как мы планируем различные задачи, и как наш мозг фактически управляют этими задачами.

Опять же, вернемся к написанию этого текста в качестве метафоры. Мой грубый ментальный план заключается в том, чтобы продолжать писать и писать, последовательно по плану, который я «набросал» в своей голове. Я не планирую никаких прерываний или другой активности при письме. Но тем не менее, мой мозг все же переключается все время.

Несмотря на то, что на операционном уровне наш мозг асинхронный, мы, похоже, планируем задачи последовательно, синхронно. «Мне нужно пойти в магазин, потом купить молока, а потом постирать белье».

Кажется, что формулировке планирования нет ничего асинхронного. На самом деле, это редкость для нас сознательно думать исключительно о событиях. Вместо этого мы планируем все тщательно, последовательно (A, затем B, затем C), и мы предполагаем своего рода временную блокировку, которая заставляет B ждать события A и C ждать события B.

Когда разработчик пишет код, он планируют выполнить ряд действий. Если это хороший разработчик, он тщательно планирует это. «Мне нужно установить `z` значение `x`, а затем `x` значение `y`» и так далее.

Когда мы пишем синхронный код, оператор за оператором, он очень похож на ToDo-лист:

```javascript
z = x;
x = y;
y = z;
```
Эти три оператора присваивания являются синхронными, а значит `x = y` ждет завершения `z = x`, и `y = z`, в свою очередь, ждет завершения `x = y`. Другой способ это указать, что эти три утверждения связаны временем с выполнением в определенном порядке, один за другим. К счастью, нам не нужно беспокоиться о каких-либо асинхронных событиях здесь. Если бы мы это сделали, код стал бы намного сложнее!

Итак, синхронное планирование мозга хорошо работает с синхронными операторами кода. Насколько хорошо наши мозг работает при планировании асинхронного кода?

Оказывается, описание асинхронности (с помощью колбэков) в нашем коде, не очень хорошо соотносится с синхронным планированием мозга.

Можете ли вы представить такую ситуацию?

Мне нужно пойти в магазин, но по дороге я уверен, что мне позвонят, так что «Привет, мам», и когда она заговорит, я буду искать адрес магазина по GPS, но загрузка займет, поэтому я выключу радио, чтобы я мог услышать маму лучше, затем я пойму, что забыл надеть куртку, и на улице холодно, но это неважно, продолжаю вести машину и разговаривать с мамой, а затем машину напомнит, что я не пристегнут, так что «Да, мама, я надеваю ремень безопасности всегда!». Ах, наконец, GPS загрузил маршурт...

Как бы смешно это ни звучало, но именно так наши мозги работают на функциональном уровне. Помните, что это не многозадачность, это просто быстрое переключение между контекстами.

Причина, по которой нам сложно разрабатывать асинхронный код, особенно когда все, что у нас есть, это колбеки, заключается в том, что мыслить и планировать «потоком» противоестественно для нас.

Мы думаем поэтапно, но инструменты (колбэки), доступные нам в коде, не выражаются поэтапно, как только мы переходим от синхронного к асинхронному.

И **поэтому** так сложно точно написать и проанализировать асинхронный JS-код с колбэками: потому что работа нашего мозга устроена иначе.

**Замечание**: Единственное, что хуже непонимания почему код не работает, это непонимание того, а почему он вообще работал! Это классический пример «карточного домика»: «он работает, но я не знаю почему, поэтому не трожьте его!» Возможно, вы слышали выражение: «Ад, это другие люди» (Сартр). У программистов есть своя версия: «Ад - это код других людей». Я убежден: «Ад — это непонмание своего собсивенного кода». И колбеки являются одним из главных виновников.

## Вложенные/связанные колбэки

Рассмотрим такой код:

```javascript
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );
```

У нас есть цепочка из трех вложенных функций, каждая из которых представляет шаг в асинхронной серии (задача, «процесс»).

Такой код часто называют «callback hell», а иногда даже «пирамидой обреченности» (из за бокового отступа).

Но «callback hell» фактически не имеет отношения ко вложенности или отспупам. Эта проблема гораздо более глкбокая. Дальше мы рассмотрим, что к чему.

Сначала мы ждем события «клика», затем мы ждем, когда таймер выполнится, мы ожидаем ajax-ответа, затем можем повторить все снова.

На первый взгляд, асинхронная работа этого кода кажется очевидной.

Сначала (*сейчас*):

```javascript
listen( "..", function handler(..){
	// ..
} );
```

*Потом*:

``` javascript
setTimeout( function request(..){
	// ..
}, 500) ;
```

Все еще *потом*:

```javascript
ajax( "..", function response(..){
	// ..
} );
```

Наконец еще *позже*:

```javascript
if ( .. ) {
	// ..
}
else ..
```

Есть несколько проблем, относительно линейности этого кода.

Во-первых, это случайность, что шаги выполения нашей программы выполняются ступенчато (друг за другом). Реальный код чаще всего содержит гораздо больше запутанностей и нюансов, о которых мы должны помнить, когда переходим от одной функции к другой. Понимание асинхронного потока в таком коде (с колбэками) не является чем то невозможным. Но это сложно, даже с учетом большой практики.

Но в этом коде есть нечто более *глубокое*, неочевидное. Позвольте мне предложить другой пример в виде псевдокода, чтобы проиллюстрировать свою мысль:

```javascript
doA( function(){
	doB();

	doC( function(){
		doD();
	} )

	doE();
} );

doF();
```

В то время как опытный из вас правильно определит истинный порядок операций здесь, я готов поспорить, что на первый взгляд он немного сбивает с толку и принимает некоторые согласованные ментальные циклы. Операции будут выполняться в следующем порядке:

Готов поспорить, что с первого взгляда этот код может сбить с толку. Хотя опытные разработчики, конечно, сразу поняли правильный порядок операций:

* `doA()`
* `doF()`
* `doB()`
* `doC()`
* `doE()`
* `doD()`

А вы поняли првильный порядок с первого раза?

Хорошо, некоторые из вас думают, что я специально выбрал такие имена функциё, чтобы преднамеренно ввести вас в заблуждение. Клянусь, я просто назвал порядок сверху вниз. Но давайте попробуем еще раз:

```javascript
doA( function(){
	doC();

	doD( function(){
		doF();
	} )

	doE();
} );

doB();
```

Теперь я назвал их в алфавитном порядке. Но я все еще держу пари, что для некоторых, порядрк `A -> B -> C -> D -> E ->` кажется неочевидным. Ваши глаза очень много прыгают по коду, не так ли?

Но даже, если для вас выполение этого кода очеыидно, то есть еще одна опасность. Заметили ее?

Что если, `doA(..)` или `doD(..)` на самом деле не асинхронные, как мы, очевидно, предположили? Ох, теперь порядок отличается. Если обе функции синхронные (такое возможно только в редком случае, в зависимости от условий программы), порядок будет  `A -> C -> D -> F -> E -> B`.

Тот звук который вы сейчас услышали, который вы только что слышали на заднем плане, это вздох тысяч JS-разработчиков, сделавших фейспалм.

Так проблема во вложенности? Неужели из за нее сложно следить за асинхронностью? Отчасти.

Позвольте, я перепишу наш пример, не используя вложенность:

```javascript
listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
```

Это вариант не так сложно анализировать, как предыдущий со вложенностью. Но тем не менее — это все еще «callback hell». Почему?

Когда мы переходим к последовательному анализу этого кода, мы должны переходим от одной функции до следующей, следующей и в итоге вырисовываем себе всю карту последовательности. И помните, что это упрощенный код. Мы знаем, что настоящие асинхронные JS-программны порой фантастически запутаны, что делает анализ кода на порядок сложнее.

**Еще одно замечание: чтобы последовательно связать шаги 2, 3 и 4 , единственные обратные вызовы, предоставляемые нами только по отдельности, дают нам твердое кодирование шага 2 на шаг 1, шаг 3 на шаг 2, этап 4 на этап 3, и так далее. Hardcoding не обязательно является плохим, если это действительно фиксированное условие, что шаг 2 всегда должен привести к шагу 3.**

Хардкод определенно делает код более хрупким, поскольку он не учитывает ситауции, когда что-то идет не так. Например, если шаг 2 *падает*, шаг 3 никогда не выполнится, а шаг 2 не повторится или не перейдет к альтернативному потоку обработки ошибок и т. д.

Все эти проблемы *можно* захардкодить руками, но тогда этот код нельзя будет использовать повтороно в других частях программы.

Несмотря на то, что наш мозг могжет планировать ряд задач в последовательном виде (это, затем это, а затем и это), восстановление этого процесса происходит очень легко. Наример, вы выполняете поручения, и понимаете, что оставили свой список покупок дома. Это незалпанированное событие, но оно не завершает ваш день. Ваш мозг легко исправляет эту ситуацию: вы идете домой, забираете список, а затем отправляетесь обратно в магазин.

Но хрупкий характер хардкодных колбеков (даже при запрограммированной обработке ошибок) не такой изящниый. После того, как вы закончите описывать (предугадывать) все различные варианты, код становится настолько запутанным, что его сложно будет поддерживать или обновлять.

Вот что такое «callback hell»! Вложенность / отступы - это уже вторично.

И, если кому то и этого недостаточно, то мы даже не коснулись того, что происходит, когда две или более цепочки этих колбэков выполняются одновременно или когда третий шаг разветвляется на «параллельные» колбеки с помощью «затворов» или «прищепок» ... OMG, мой мозг взорвался, как там ваш?!

Вы понимаете, что наше последовательное, блокирующее поведение в планировании мозга не согласуется с асинхронным кодом в виде колбэков? Это первый серьезный недостаток, заключающийся в том, чтобы выразить суть колбэков: они описывают асинхронность кода, в то время, как наш мозг пытается работать синхронно!
