# Вы не знаете JS: Асинхронность и Производительность
# Глава 3: Промисы

В Главе 2 мы выявили две основные категории недостатков при использовании колбэков для выражения асинхронности программы и управления параллелизмом: отсутствие последовательности и проблема доверия (инверсия контроля). Теперь, когда мы более глубоко понимаем проблемы, пришло время обратить внимание на паттерны, которые должны эти проблемы решить.

Проблема, которую мы хотим решить в первую очередь — это инверсия контроля, доверие, которое так тяжело удержать и так легко потерять.

Напомним, что мы оборачиваем *продолжение* нашей программы в колбэк, передаем его исполнение другой (возможно, сторонней) программе и скрестив пальцы надеемся, что все будет работать правильно.

Мы делаем это, потому что хотим сказать: «вот что произойдет *позже*, после того, как завершится текущий шаг».

Но что, если бы мы смогли избавиться от этой инверсии контроля? Что, если вместо того, чтобы передать *продолжение* нашей программы другой стороне, мы могли бы ожидать, что она даст нам возможность узнать, когда закончится выполнение ее задачи? Что, если бы наша программа решала, что делать дальше?

Эта парадигма называется **Промисы**

Промисы стремительно ворвались в мир JS, поскольку к тому времени разработчики отчаянно боролись с «callback hell» в своем коде. Фактически, большинство новых асинхронных API, создаются на промисах. Так что, наверное, неплохо бы изучить их, не так ли?

**Примечание:**. Слово «немедленно» будет использоваться часто в этой главе, как правило, для ссылки на какое-либо действие промисов.ы

## Что такое промис?

Когда разработчики решают научиться новой технологии, обычно их первым шагом является «Покажите мне код!». Для нас совершенно естественно начинать прыгать, когда мы только учимся ходить.

Но оказывается, что некоторые абстракции тяжело понять только по API. Промисы - один из тех инструментов, где это особенно очевидно. Это становится серьезной проблемой для тех, кто не изучает промисы, а сразу переходит к использованию API.

Поэтому, прежде чем я покажу код промисов, я хочу полностью объяснить концепцию, лежащую в их основе. Я надеюсь, что это поможет вам лучше применять их на практике.

Давайте посмотрим на две разные аналогии, объясняющие суть промисов.

## Будущее значение

Представьте себе такую ситуацию: я подхожу к стойке в ресторане быстрого питания и заказываю чизбургер. Передав деньги, я создал своего рода запрос, в ответ на который я получу чизбургер. Я начал транзакцию.

Но не всегда в ответ на такой запрос чизбургер возвращается сразу. Кассир вручает мне нечто вместо моего чизбургер: квитанцию с номером заказа на нем. Этот номер заказа — это долговое обязательство («Я должен вам»), которое гарантирует, что в конечном итоге я должен получить чизбургер.

Пока я жду, я могу делать другие вещи, например, написать сообшение другу: «Пообедаешь со мной? Я буду есть чизбургер».

Я уже рассуждаю о моем *будущем чизбургер*, хотя у меня его еще нет. Номер заказа мой мозг использует, как аналогию, временный «заменитель» чизбургера. «заменитель» существенно делает значение независимым от времени. Это **будущая ценность**.

В конце концов, я слышу: «Заказ 113!» и я радостно возвращаюсь к стойке с квитанцией в руке. Я вруая свою квитанцию кассиру, и получаю чизбургер взамен.

Другими словами, как только моя **будущая ценность** была готова, я обменял квитанцию о ценности на саму ценность.

Но есть еще один вариант событий. Они называют мой номер заказа, но когда я иду, чтобы получить чизбургер, кассир с сожалением сообщает мне: «Извините, но мы, кажется, продали все чизбургкры». Отбросив мое разочарование на мгновение, мы можем увидеть важную характеристику будущих значений: они могут означать либо успех, либо неудачу.

Каждый раз, когда я заказываю чизбургер, я знаю, что в конечном итоге я получу чизбургер, или я получу печальную новость о том, что они кончились, и мне придется выяснять, что еще есть на обед.

**Примечание:** В коде все не так просто, потому что метафорически номер заказа может быть никогда не вызван, и в этом случае мы остаемся на неопределенное время в неопределенном состоянии. Мы вернемся к этому позже.

### Значения сейчас и потом

Конечно это все звучит довольно абстрактно. Давайте конкретизируем.

Однако, прежде чем мы сможем представить, как Промисы работают, возьмем решение, которое мы уже изучили - колбэки! - посмотрим, как они спрявятся с *будущими значениями*.

Когда вы пишете код, оперируя значением, например, выполняя математические действия с числами, понимаете ли вы это или нет, вы принимаете что-то очень фундаментальное в отношении этого значения, то есть это конкретное значение *уже сейчас*:

```javascript
var x, y = 2;

console.log( x + y ); // NaN  <-- потому что `x` еще не установлено значение
```

Операция `x + y` предполагает, что значения и `x`, и `y` уже установлены. Иными словами, мы предполагаем, что значения `x` и `y` уже *разрешены*.

**Было бы бессмысленно ожидать, что оператор `+` сам каким-то образом будет способен обнаруживать и ждать до тех пор, пока не будут разрешены как `х`, так и `y` (ака готовы), только тогда, чтобы выполнить операцию. Это может привести к хаосу в программе, если разные заявления закончатся сейчас, а другие - позже, верно?**

**Как вы могли бы рассуждать о взаимоотношениях между двумя операторами, если один из них (или обоих) может еще не закончить? Если оператор 2 полагается на завершение 1-го утверждения, есть только два результата: либо закон 1 закончен прямо сейчас, и все идет хорошо, либо оператор 1 еще не завершился, и, следовательно, утверждение 2 будет терпеть неудачу.**

Отлично, если это вам показалось похожим на то, что мы изучали в первой главе.

Вернемся к нашей математической операции `x + y`. Представьте себе, что существует способ сказать: «Сложи `x` и `y`, но если какого-то из значений еще нет, то подождите, пока оба значения будут установлены. И сложи их, как только сможешь».

Возможно, ваш мозг предложит вам решение на колбэках. Итак...

```javascript
function add(getX,getY,cb) {
	var x, y;
	getX( function(xVal){
		x = xVal;
		// оба значения готовы?
		if (y != undefined) {
			cb( x + y );	// сложить значения
		}
	} );
	getY( function(yVal){
		y = yVal;
		// оба значения готовы?
		if (x != undefined) {
			cb( x + y );	// сложить значения
		}
	} );
}

// `fetchX()` and `fetchY()` are sync or async
// functions
add( fetchX, fetchY, function(sum){
	console.log( sum ); // that was easy, huh?
} );
```

Хотя уродство этого кода неоспоримо, нужно кое-что подчеркнуть.

В этом фрагменте мы рассматривали `x` и `y`, как будущие значения, и мы выражаем операцию `add(..)`, которую не волнует, доступны ли `x` или `y` сразу или нет. Иными словами функция согласует понятия *сейчас* и *потом*, поэтому мы можем полагаться на предсказуемый результат операции `add(..)`.

Используя фунцкцию `add(..)`, согласованную по времени — она ведет себя одинаково `сейчас` и `позже` — мы получаем асинхронный код, который гораздо проще анализировать.

Иными словами: последовательно обрабатывать как сейчас, так и позже, мы делаем их обе позже: все операции становятся асинхронными.

Конечно, написанные на коленке код, основанный на коолбэках, оставляет желать лучшего. Это всего лишь первый шаг к пониманию преимущества анализа *будущих значений*, не беспокоясь о времени, когда значения доступны или  еще нет.

### Значения промисов

Мы обязательно подробно расскажем о промисах позже в этой главе - так что не волнуйтесь, если некоторые вам будут непонятны. Давайте просто кратко взглянем на то, как мы можем реализовать пример `x + y` через Промисы:

```javascript
function add(xPromise,yPromise) {
	// `Promise.all([ .. ])` принимает массив промисов,
	// и возвращает новый промис
	// который ждет, пока остальные ппрмисс из массива зарезолвятся
	return Promise.all( [xPromise, yPromise] )

	// когда и этот промис зарезолвится,
	// возьмем полученные значения `X` and `Y` и сложим вместе.
	.then( function(values){
		// `values` это массив вернувшийся
		// в результате резолва предыдущих промисов
		return values[0] + values[1];
	} );
}

// `fetchX()` and `fetchY()` возвращают промисы для значений X и Y соответственно, которые могут быть готовы
// *сейчас* или *потом*.
add( fetchX(), fetchY() )

// мы получаем промис, возвращающий сумму
// двух чисел.
// по цепочке мы вызываем `then(..)` ждущий резолва
// вернувшегося промиса.
.then( function(sum){
	console.log( sum ); //
} );
```

В этом примере есть два уровня промисов.

`fetchX()` и `fetchY()` вызываются напрямую, а возвращаемые значения (в виде промисов) передаются в `add(..)`. Значения, которые возвращают промисы, могут быть готовы *сейчас* или *позже*, но каждый промис упорядочивает своюб работу независимо от этого. Мы рассуждаем о значениях `X` и `Y` независимо от времени. Это будущие значения.

Второй уровень - это промис, создаваемый`add(..)` (с помощью `Promise.all ([..])`), возврата которого мы ждем, вызывая `then(..)`. Когда операция `add(..)` завершается, наши будущие жначения будут готовы, и мы можем их использовать. Мы скрываем внутри `add(..)` логику ожидания значений `X` и `Y`.

**Примечание:** Внутри `add(..)` вызов `Promise.all([..])` создает промис (который ждет резолва по `promiseX` и `promiseY`). Вызов `.then (..)` создает другой промис, которое сразу же резолвит значение `return values[0] + values[1]` (с результатом сложения). Таким образом, вызов `then(...)`, который мы связываем с завершением вызова `add(..)` — в конце примера — фактически работает над возвратом второго промиса, а не первого, созданного `Promise.all([ .. ])`. Кроме того, хотя мы не связываем конец `then(..)`, он тоже создало другой промис, рузультат которого мы можешм использовать, если что. Этот механизм связывания промисов будет рассмотрен более подробно позже в этой главе.

Как и в случае с заказом чизбургера, возможно, что результат промиса - это реджект (т.е ошибка, отказ), а не резолв. В отличие от выполненного (зарезолвленного) промиса, значение которого зарпошраммировано, значение реджекта, может быть либо задано непосредственно логикой программы, либо оно может неявно вытекать во время выполнения программы.

Таким образом `then(...)` может фактически пррнимать две функции, первую для выполнения (как показано выше), а вторую для отказа

**ЗАМЕНИТЬ РЕЗОЛВ И РЕДЖЕКТ НА ВЫПОЛНИЛСЯ/ОТКЛОНИЛСЯ**

```javascript
add( fetchX(), fetchY() )
.then(
	// обработка выполнения
	function(sum) {
		console.log( sum );
	},
	// обработка отказа
	function(err) {
		console.error( err ); // bummer!
	}
);
```

Если что-то пошло не так, при получении значений `X` или `Y` или при сложении, промис, который возвращает `add(..)`, будет отклонен, а второй обработчик ошибок, переданный в `theb(..)`, получит значение отклонения.

Поскольку промис инкапсулируют зависящее от времени состояние( ожидание выполнения или отклонения) отвнешней среды, то сам промис не зависит от времени, и, таким образом, промисы ведут себя предсказуемо.

Более того, как только промис выполнятеся, его значение становится *неизменяемым*. Его можно использовать столько раз сколько потребуется.

**Примечание:** Поскольку промис является неизменным после его выполнения, то его значение можно передавать куда угодно, и быть уверенным что его нельзя модифицировать случайно или намеренно. Это особенно верно в отношении нескольких частей программы, использующих значение промиса. Невозможно, чтобы одна часть повлияла на способность другой части использовать это значение. Неизменяемость (иммутабельность) может звучать по-академически сложно, но на самом деле это один из самых фундаментальных и важных аспектов дизайна промисов.

Это одно из самых сильных и важных понятий для понимания промисов.

Промисы — это удобная концепия для повторной работы с *будущими значениями*.

### Событие завершения

Как мы только что видели, отдельный промис ведет себя, как `будущее значение`. Но есть еще один способ выразить работу о работе промисов: как механизм управления потоком по времени (`это-затем-то`) для двух или более шагов в асинхронной задаче.

Представим себе вызов функции `foo(..)` для выполнения некоторой задачи. Мы не знаем ни о каких деталях ее работы, да и в общем они нам и не нужны. Функция  может выполнить задачу сразу, или это может занять некоторое время.

Нам просто нужно знать, когда `foo(..)` заканчится, чтобы мы могли перейти к следующей задаче. Другими словами, мы хотели бы получить уведомление о завершении `foo(..)`, чтобы *продолжить*.

В JavaScript, если вам нужно подписаться на уведомление, вы, вероятно, подумаете об этом с точки зрения событий. Таким образом, мы могли бы пересмотреть нашу потребность в уведомлении так: нам нужно подписаться на событие `завершения` (`или продолжения`), переданное от `foo(..)`.

**Примечание:** Использование «события завершения» или «события продолжения», зависит от ваших дальнейших действий. Что нам нужно: то, что происходит во время `foo(..)`, или что происходит после завершения `foo(..)`? Оба этих действия важны. Уведомление о событии не только сообщает нам, что `foo(..)` *завершено*, но также говорит нам, что все в порядке, чтобы *продолжить* следующий шаг. Действительно, колбэк, который вы передаете для вызова уведомления о событии, сам по себе является тем, что мы ранее называли *продолжением*. **Поскольку *событие завершения* немного больше сфокусировано на `foo(..)`, на что в наше время больше внимания, мы немного одобряем событие завершения для остальной части этого текста.**

В версии с колбэками «уведомление» будет колбэком, вызванным задачей (`foo(..)`). Но с промисами мы  ожидаем, что мы сможем прослушать событие из `foo(..)`, и, когда вас уведомят, то сделать соответствующие действия.

Рассмотрим следующий псевдокод:

```javascript
foo(x) {
	// начинаем делать то, что зай мет некоторое время
}

foo( 42 )

on (foo "completion") {
	// теперь мы можем приступить к слудующему шагу!
}

on (foo "error") {
	// упс, что-то пошло не так в `foo(..)`
}
```

Мы вызываем `foo(..)`, а затем устанавливаем два прослушивателя событий, один для «завершения» и один для «ошибки» — двух возможных конечных результата вызова `foo(..)`. По сути, `foo(..)` не знает, что вызывающий код подписался на эти события, что дает очень хорошее `разделение сущностей`.

К сожалению, для такого кода потребуется некоторая «магия», которой не существует в JS. Вот более естественный способ описать это в JS:

```javascript
function foo(x) {
	// начинаем делать то, что зай мет некоторое время

	// создаем `listener`, уведомляющий о событии

	return listener;
}

var evt = foo( 42 );

evt.on( "completion", function(){
	// теперь мы можем приступить к слудующему шагу!
} );

evt.on( "failure", function(err){
	// упс, что-то пошло не так в `foo(..)`
} );
```
`foo(..)` создает возможность подписки на события для возврата, а вызывающий `foo` код получает и регистрирует два обработчика событий.

Инверсия из нормального обратного кода должна быть очевидной, и это преднамеренно. Вместо того, чтобы передавать обратные вызовы в foo (..), он возвращает функцию события, которую мы вызываем evt, которая получает обратные вызовы.

Должно быть очевидным отличие от обычного (колбэчного) кода. Вместо того, чтобы передавать олбэки в `foo(..)`, мы вызываем функцию события, которая принимает колбэки.

Но вспомните главу 2 — сами колбэки подвержены `инверсии контроля`. Поэтому инвертирование шаблона колбэка на самом деле является `инверсией инверсии`  — восстановлением контроля обратно.

Одним из важных преимуществ является то, что нескольким отдельным частям кода может быть предоставлена возможность прослушивания событий, и они могут независимо получать уведомления о том, когда `foo(..)` завершает выполнение:

```javascript
var evt = foo( 42 );

// let `bar(..)` listen to `foo(..)`'s completion
bar( evt );

// also, let `baz(..)` listen to `foo(..)`'s completion
baz( evt );
```
`Анинверсия контроля `позволяет лучше отделить код, т.к `bar(..) `и `baz(..)` не нужно участвовать в вызове `foo(..)`. Точно так же `foo(..)` не нужно знать, что `bar(..)` и `baz(..)` существуют или ждут уведомления завершении `foo()`.


По сути, `evt` является нейтральным состоянием соглашением между отдельными проблемами.

### Промис "События"

Как вы уже догадались, возможность прослушивания событий `evt` является аналогом промисов.

В варианте, основанном на промисах, предыдущий фрагмент кода создавал бы `foo()` и возвращал экземпляр промиса, и этот промис затем передавался бы в `bar(..)` и `baz(..)`.

`Примечание:` «События», которые мы слушаем — это не события в прямом смысле (хотя они, безусловно, ведут себя именно так), и их обычно не называют «завершением» или «ошибкой». Вместо этого мы используем `then(..)` для регистрации события «then». Или более точно — `then(..)` регистрирует событие `fulfillment(выполнение)` и / или `rejection (отклонение)`, хотя явно мы не видим их использования в коде.

Рассмотрим пример:

```javascript
function foo(x) {
	// start doing something that could take a while

	// construct and return a promise
	return new Promise( function(resolve,reject){
		// по сути, вызов `resolve(..)` или `reject(..)`,
		// это варианты колбэков для выполнения
		// промиса.
	} );
}

var p = foo( 42 );

bar( p );

baz( p );
```

**Примечание:**. Паттерн `new Promise (function (..) {..})`, обычно называется «раскрывающим конструктором». Передаваемая функция выполняется немедленно (не async отложен, так как обратные вызовы тогда (..)), и ей передаются два параметра, которые в этом случае мы назвали `resolve` и `reject`. Это функции выполнения промиса. `resolve(..)` отвечает за `fulfillment`-стадию и `reject(..)` за `rejection`-стадию.

Вероятно, вы можете догадаться,`bar(..)` и `foo(..)` внутри:

```javascript
function bar(fooPromise) {
	// слушаем, когда `foo(..)` закончится
	fooPromise.then(
		function(){
			// `foo(..)` закончилась, so
			// выполняем `bar(..)`
		},
		function(){
			// упс, что-то пошло не так в `foo(..)`
		}
	);
}

// то жк самое для `baz(..)`
```

Другой вариант:

```javascript
function bar() {
	// `foo(..)` определенно завершилсь, so
	// выпрлняем `bar(..)`
}

function oopsBar() {
	// цпс, что-то пошло не так в foo(..)`,
	// `bar(..)` не запустится
}

// тоже самое для `baz()` и `oopsBaz()`

var p = foo( 42 );

p.then( bar, oopsBar );

p.then( baz, oopsBaz );
```
**Примечание:** Если раньше вы уже использовали промисы, то вы можете предположить, что последние две строки этого кода можно записать как `p.then( .. ).then( .. )`, используя связывание. У такого варианта было бы совершенно другое поведение, поэтому будьте осторожны! Разница может быть не совсем понятна прямо сейчас, но на самом деле это другой асинхронный шаблон:` split / forking`. Не волнуйтесь! Мы еще вернемся к этому вопросу позже в этой главе.

Вместо того, чтобы передавать промис в `bar(..)` и `baz(..)`, мы используем промис для контроля того, когда `bar(..)` и `baz(..)` будут выполняться, если это вообще произойдет. Основное различие заключается в обработке ошибок.

В первом случае `bar(..)` вызывается независимо от того, как завершится `foo(..)` (успешно или нет), и обрабатывает свою собственную логику на случай, если получено уведомление, что `foo(..)` «упало». То же самое верно для `baz(..)`.

Во втором случае `bar(..)` вызывается только в том случае, если `foo(..)` завершается успешно, иначе вызывается `oopsBar(..)`. То же для `baz(..)`.

Ни один из подходов не является правильным. Будут случаи, когда один предпочтительнее другого.

В любом случае промис `p`, возвращаемый от `foo(..)`, используется для контроля того, что произойдет дальше.

Более того, тот факт, что оба фрагмента заканчиваются вызовом `then(..)` иллюстрирует ранее сделанный вывод, которая заключается в том, промисы после выполнения навсегда сохраняют одно и то же значение (`fullfillment`или `rejection`).


Всякий раз, когда `p` выполнится, следующий шаг всегда будет таким же, как `сейчас`, так и `позже`.
