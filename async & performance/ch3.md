# Вы не знаете JS: Асинхронность и Производительность
# Глава 3: Промисы

В Главе 2 мы выявили две основные категории недостатков при использовании колбэков для выражения асинхронности программы и управления параллелизмом: отсутствие последовательности и проблема доверия (инверсия контроля). Теперь, когда мы более глубоко понимаем проблемы, пришло время обратить внимание на паттерны, которые должны эти проблемы решить.

Проблема, которую мы хотим решить в первую очередь — это инверсия контроля, доверие, которое так тяжело удержать и так легко потерять.

Напомним, что мы оборачиваем *продолжение* нашей программы в колбэк, передавая его исполнение другой (возможно, сторонней) программе и скрестив пальцы надеемся, что все будет работать правильно.

Под продолжением подразумевается это: «вот что произойдет *позже*, после того, как завершится текущий шаг».

Но что, если бы существовала парадигма, позволяющая избавиться от этой инверсии контроля? Что, если вместо того, чтобы передать *продолжение* нашей программы другой стороне, мы могли бы ожидать, что программа даст нам возможность узнать, когда закончится выполнение ее текущего шага? Что, если бы наша программа решала, что делать дальше?

Эта парадигма называется **Промисы**

Промисы стремительно ворвались в мир JS, поскольку к тому времени разработчики отчаянно боролись с «callback hell» в своем коде. Фактически, большинство новых асинхронных API, создаются на промисах. Так что, наверное, неплохо бы изучить их, не так ли?

**Примечание:**. Слово «немедленно» будет использоваться часто в этой главе, как правило, для ссылки на какое-либо действие промисов.

## Что такое промис?

Когда разработчики решают научиться новой технологии, обычно первым делом они сразу приступают к изучению синтаксиса этой технологии. Для нас совершенно естественно начинать прыгать, когда мы только учимся ходить.

Но оказывается, что некоторые абстракции тяжело понять только по API. Промисы — один из тех инструментов, где это особенно очевидно. Это становится серьезной проблемой для тех, кто не изучает механизмы работы промисов, а сразу переходит к использованию API.

Поэтому, прежде чем я покажу код промисов, я хочу полностью объяснить концепцию, лежащую в их основе. Я надеюсь, что это поможет вам лучше применять их на практике.

Давайте посмотрим на две разные аналогии, объясняющие суть промисов.

### Будущее значение

Представьте себе такую ситуацию: я подхожу к стойке в кафе и заказываю чизбургер. Передав деньги, я создал своего рода запрос, в ответ на который я получу чизбургер. Я начал транзакцию.

Но не всегда в ответ на такой запрос чизбургер возвращается сразу. Кассир вручает мне нечто вместо моего чизбургер: квитанцию с номером заказа на нем. Этот номер заказа — это долговое обязательство («Я должен вам»), которое гарантирует, что в конечном итоге я должен получить чизбургер.

Пока я жду, я могу делать другие вещи, например, написать сообщение другу: «Пообедаешь со мной? Я буду чизбургер».

Я уже рассуждаю о моем *будущем чизбургере*, хотя у меня его еще нет. Номер заказа мой мозг использует, как аналогию, временный «заменитель» чизбургера. «Заменитель» делает значение независимым от времени. Это **будущая ценность**.

В конце концов, я слышу: «Заказ 113!» и я радостно возвращаюсь к стойке с квитанцией в руке. Я вручаю свою квитанцию кассиру, и получаю чизбургер взамен.

Другими словами, как только моя **будущая ценность** была готова, я обменял квитанцию о ценности на саму ценность.

Но есть еще один вариант событий. Кассир называет мой номер заказа, но когда я иду, чтобы получить чизбургер, кассир с сожалением сообщает мне: «Извините, но мы, кажется, продали все чизбургеры». Отбросив мое разочарование на мгновение, мы можем увидеть важную характеристику будущих значений: они могут означать либо успех, либо неудачу.

Каждый раз, когда я заказываю чизбургер, я знаю, что в конечном итоге я получу или чизбургер, или печальную новость о том, что они кончились, и мне придется выяснять, что еще есть на обед.

**Примечание:** В коде все не так просто, потому что метафорически номер заказа может быть никогда не вызван, и в этом случае мы остаемся на неопределенное время в неопределенном состоянии. Мы вернемся к этому позже.

#### Значения сейчас и потом

Конечно это все звучит довольно абстрактно. Давайте конкретизируем.

Однако, прежде чем мы сможем представить, как промисы работают, возьмем решение, которое мы уже изучили - колбэки! - посмотрим, как они справятся с *будущими значениями*.

Когда вы пишете код, оперируя значением, например, выполняя математические действия с числами, понимаете ли вы это или нет, вы подразумеваете что-то очень фундаментальное в отношении этого значения, то есть это конкретное значение *уже сейчас*:

```javascript
var x, y = 2;

console.log( x + y ); // NaN  <-- потому что `x` еще не установлено значение
```

Операция `x + y` предполагает, что значения и `x`, и `y` уже установлены. Иными словами, мы предполагаем, что значения `x` и `y` уже *разрешены (получены)*.

Было бы бессмысленно ожидать, что оператор `+` сам каким-то образом будет способен обнаруживать и ждать до тех пор, пока не будут разрешены (иначе говоря, готовы) как `х`, так и `y`, и только тогда выполнять операцию. Это может привести к хаосу в программе.

Как бы мы тогда рассуждали о взаимодействии между двумя инструкциями, если одна из инструкций еще в ожидании? Если вторая инструкция полагается на завершение первой, то возможны два результата: либо первая инструкция завершается прямо *сейчас*, и все идет хорошо, либо инструкция еще не завершилась, и, следовательно, вторая инструкция не выполнится.

Отлично, если это вам показалось похожим на то, что мы изучали в первой главе.

Вернемся к нашей математической операции `x + y`. Представьте себе, что существует способ сказать: «Сложи `x` и `y`, но если какого-то из значений еще нет, то подожди, пока оба значения будут установлены. И сложи их, как только сможешь».

Возможно, ваш мозг предложит вам решение на колбэках. Итак...

```javascript
function add(getX, getY, cb) {
	var x, y;
	getX( function(xVal){
		x = xVal;
		// оба значения готовы?
		if (y != undefined) {
			cb( x + y );	// сложить значения
		}
	} );
	getY( function(yVal){
		y = yVal;
		// оба значения готовы?
		if (x != undefined) {
			cb( x + y );	// сложить значения
		}
	} );
}

// `fetchX()` и`fetchY()` могут быть синхронными или асинхронными
// functions
add( fetchX, fetchY, function(sum){
	console.log( sum ); // это было просто, да?
} );
```

Хотя уродство этого кода неоспоримо, нужно кое-что подчеркнуть.

В этом фрагменте мы рассматриваем `x` и `y`, как будущие значения, и мы описываем операцию `add(..)`, которую не волнует, доступны ли `x` или `y` сразу или нет. Иными словами функция согласует понятия *сейчас* и *потом*, поэтому мы можем полагаться на предсказуемый результат операции `add(..)`.

Используя функцию `add(..)`, согласованную по времени — она ведет себя одинаково и `сейчас` и `позже` — мы получаем асинхронный код, который гораздо проще анализировать.

Иными словами: последовательно обрабатывая как `сейчас`, так и `позже`, мы выполняем их оба `позже`. То есть асинхронно.

Конечно, написанный на коленке код, основанный на колбэках, оставляет желать лучшего. Это всего лишь первый шаг к пониманию преимущества анализа *будущих значений*, не беспокоясь о том доступны ли эти значения или еще нет.

#### Значения промисов

Мы обязательно подробно расскажем о промисах позже в этой главе - так что не волнуйтесь, если некоторые определения вам будут непонятны [речь о реджекте и резолве. — _прим. перев_.]. Давайте просто кратко взглянем на то, как мы можем реализовать пример `x + y` через Промисы:

```javascript
function add(xPromise,yPromise) {
	// `Promise.all([ .. ])` принимает массив промисов,
	// и возвращает новый промис
	// который ждет, пока остальные промисы из массива зарезолвятся
	return Promise.all( [xPromise, yPromise] )

	// когда и этот промис зарезолвится,
	// возьмем полученные значения `X` and `Y` и сложим вместе.
	.then( function(values){
		// `values` это массив вернувшийся
		// в результате резолва предыдущих промисов
		return values[0] + values[1];
	} );
}

// `fetchX()` and `fetchY()` возвращают промисы для значений X и Y соответственно, которые могут быть готовы
// *сейчас* или *потом*.
add( fetchX(), fetchY() )

// мы получаем промис, возвращающий сумму
// двух чисел.
// по цепочке мы вызываем `then(..)` ждущий резолва
// вернувшегося промиса.
.then( function(sum){
	console.log( sum ); //
} );
```

В этом примере есть два уровня промисов.

`fetchX()` и `fetchY()` вызываются напрямую, а возвращаемые значения (в виде промисов) передаются в `add(..)`. Значения, которые возвращают промисы, могут быть готовы *сейчас* или *позже*, но каждый промис выстраивает свою работу независимо от этого. Мы рассуждаем о значениях `X` и `Y` независимо от времени. Это будущие значения.

Второй уровень - это промис, создаваемый `add(..)` (с помощью `Promise.all ([..])`), возврата которого мы ждем, вызывая `then(..)`. Когда операция `add(..)` завершается, наши будущие значения будут готовы, и мы сможем их использовать. Мы скрываем внутри `add(..)` логику ожидания значений `X` и `Y`.

**Примечание:** Внутри `add(..)` вызов `Promise.all([..])` создает промис (который ждет резолва по `promiseX` и `promiseY`). Вызов `.then (..)` создает другой промис, которое сразу же резолвит значение `return values[0] + values[1]` (с результатом сложения). Таким образом, вызов `then(...)`, который мы связываем с завершением вызова `add(..)` — в конце примера — фактически работает над возвратом второго промиса, а не первого, созданного `Promise.all([ .. ])`. Кроме того, хотя мы не связываем результат второго `then(..)`, он тоже создаёт промис, результат которого мы можем использовать, если понадобится. Этот механизм связывания промисов будет рассмотрен более подробно позже в этой главе.

Как и в случае с заказом чизбургера, возможно, что результат промиса - это `реджект` (т.е ошибка, отказ), а не `резолв`. В отличие от выполненного `(зарезолвленного)` промиса, значение которого запрограммировано, значение реджекта, может быть либо задано непосредственно логикой программы, либо оно может неявно вытекать во время выполнения программы.

Таким образом `then(...)` может фактически принимать две функции, первую для резолва (как показано выше), а вторую для реджекта.

```javascript
add( fetchX(), fetchY() )
.then(
	// обработка резолова
	function(sum) {
		console.log( sum );
	},
	// обработка реджекта
	function(err) {
		console.error( err ); // bummer!
	}
);
```

Если что-то пошло не так при получении значений `X` или `Y` или при сложении, промис, который возвращает `add(..)`, будет зареджектен, а второй обработчик ошибок, переданный в `then(..)`, получит значение реджекта.

Поскольку промис инкапсулируют зависящее от времени состояние (ожидание резолва или реджекта) от внешней среды, то сам промис не зависит от времени, и, таким образом, промисы ведут себя предсказуемо.

Более того, как только промис выполняется, его значение становится *неизменяемым*. Его можно использовать столько раз сколько потребуется.

**Примечание:** Поскольку промис является неизменным после его выполнения, то его значение можно передавать куда угодно, и быть уверенным, что его нельзя модифицировать случайно или намеренно. Это особенно верно в отношении нескольких частей программы, использующих значение промиса. Невозможно, чтобы одна часть повлияла на способность другой части использовать это значение. Неизменяемость (иммутабельность) может звучать по-академически сложно, но на самом деле это один из самых фундаментальных и важных аспектов работы промисов.

Промисы — это удобная концепция для повторной работы с *будущими значениями*.

### Событие завершения

Как мы только что видели, отдельный промис ведет себя, как `будущее значение`. Но есть еще один способ выразить работу промисов: как механизм управления потоком по времени (`это-затем-то`) для двух или более шагов в асинхронной задаче.

Представим себе вызов функции `foo(..)` для выполнения некоторой задачи. Мы не знаем ни о каких деталях ее работы, да и в общем они нам и не нужны. Функция  может выполнить задачу или сразу или это может занять некоторое время.

Нам просто нужно знать, когда `foo(..)` закончится, чтобы мы могли перейти к следующей задаче. Другими словами, мы хотели бы получить уведомление о завершении `foo(..)`, чтобы *продолжить*.

В JavaScript, если вам нужно подписаться на уведомление, вы, вероятно, подумаете об этом с точки зрения событий. Иными словами: нам нужно подписаться на событие `завершения` (`или продолжения`), переданное от `foo(..)`.

**Примечание:** Использование «события завершения» или «события продолжения», зависит от наших дальнейших действий. Что нам нужно: то, что происходит во время выполнения `foo(..)`, или что происходит после завершения `foo(..)`? Оба этих действия важны. Уведомление о событии не только сообщает нам, что `foo(..)` *завершено*, но также говорит нам, что все в порядке, чтобы *продолжить* следующий шаг. Действительно, колбэк, который вы передаете для вызова уведомления о событии, сам по себе является тем, что мы ранее называли *продолжением*.

В версии с колбэками «уведомление» будет колбэком, вызванным задачей (`foo(..)`). Но с промисами мы ожидаем, что мы сможем прослушать событие из `foo(..)`, и, когда вас уведомят, то сделать соответствующие действия.

Рассмотрим следующий псевдокод:

```javascript
foo(x) {
	// начинаем делать то, что займет некоторое время
}

foo( 42 )

on (foo "completion") {
	// теперь мы можем приступить к следующему шагу!
}

on (foo "error") {
	// упс, что-то пошло не так в `foo(..)`
}
```

Мы вызываем `foo(..)`, а затем устанавливаем два слушателя событий, один для «завершения» и один для «ошибки» — двух возможных конечных результата вызова `foo(..)`. По сути, `foo(..)` не знает, что вызывающий код подписался на эти события, что дает очень хорошее `разделение сущностей`.

К сожалению, для такого кода потребуется некоторая «магия», которой не существует в JS. Вот более естественный способ описать это в JS:

```javascript
function foo(x) {
	// начинаем делать то, что займёт некоторое время

	// создаем `listener`, уведомляющий о событии

	return listener;
}

var evt = foo( 42 );

evt.on( "completion", function(){
	// теперь мы можем приступить к следующему шагу!
} );

evt.on( "failure", function(err){
	// упс, что-то пошло не так в `foo(..)`
} );
```
`foo(..)` создает возможность подписки на события для возврата, а вызывающий `foo` код получает и регистрирует два обработчика событий.

Инверсия из нормального обратного кода должна быть очевидной, это сделано намеренно. Вместо того, чтобы передавать обратные вызовы в `foo(..)`, он возвращает функцию события, которую мы вызываем `evt`, которая получает обратные вызовы.

Должно быть очевидным отличие от обычного (на колбэках) кода. Вместо того, чтобы передавать колбэки в `foo(..)`, мы вызываем функцию события, которая принимает колбэки.

Но вспомните главу 2 — сами колбэки подвержены `инверсии контроля`. Поэтому инвертирование шаблона колбэка на самом деле является `инверсией инверсии`  — восстановлением контроля обратно.

Одним из важных преимуществ является то, что нескольким отдельным частям кода может быть предоставлена возможность прослушивания событий, и они могут независимо получать уведомления о том, когда `foo(..)` завершает выполнение:

```javascript
var evt = foo( 42 );

// пусть `bar(..)` регистрирует завершение`foo(..)`
bar( evt );

// так же, пусть `baz(..)` регистрирует завершение `foo(..)`
baz( evt );
```
*Инверсия инверсии* позволяет лучше *разделить ответственность*, т.к `bar(..) `и `baz(..)` не нужно участвовать в вызове `foo(..)`. Точно так же `foo(..)` не нужно знать, что `bar(..)` и `baz(..)` существуют или ждут уведомления завершении `foo()`.

По сути, объект `evt` является нейтральным способом общения между функциями с разделённой ответственностью.

#### «Событие завершения» на промисах

Как вы уже догадались, возможность прослушивания событий `evt` является аналогом промисов.

В варианте, основанном на промисах, предыдущий фрагмент кода создавал бы `foo()` и возвращал экземпляр промиса, и этот промис затем передавался бы в `bar(..)` и `baz(..)`.

**Примечание:** «События», которые мы слушаем — это не события в прямом смысле (хотя они, безусловно, ведут себя именно так), и их обычно не называют «завершением» или «ошибкой». Вместо этого мы используем `then(..)` для регистрации события «then». Или более точно — `then(..)` регистрирует событие `fulfillment (выполнение)` и/или `rejection (отклонение)`, хотя явно мы не видим их использования в коде.


Рассмотрим пример:

```javascript
function foo(x) {
	// начинаем делать что то, что займет время

	// создаем и возвращаем промис
	return new Promise( function(resolve,reject){
		// по сути, вызов `resolve(..)` или `reject(..)`,
		// это варианты колбэков для выполнения
		// промиса.
	} );
}

var p = foo( 42 );

bar( p );

baz( p );
```

**Примечание:** Паттерн `new Promise (function (..) {..})` называется «раскрывающим конструктором (Revealing Constructor)». Передаваемая функция выполняется немедленно и ей передаются два параметра, которые мы назвали `resolve` и `reject`. Это функции выполнения промиса. `resolve(..)` отвечает за `fulfillment`-стадию и `reject(..)` за `rejection`-стадию.

Вероятно, вы можете догадаться,`bar(..)` и `foo(..)` внутри:

```javascript
function bar(fooPromise) {
	// слушаем, когда `foo(..)` закончится
	fooPromise.then(
		function(){
			// `foo(..)` закончилась, so
			// выполняем `bar(..)`
		},
		function(){
			// упс, что-то пошло не так в `foo(..)`
		}
	);
}

// то же самое для `baz(..)`
```

Другой вариант:

```javascript
function bar() {
	// `foo(..)` определенно завершилось
	// выполняем `bar(..)`
}

function oopsBar() {
	// упс, что-то пошло не так в foo(..)`,
	// `bar(..)` не запустится
}

// тоже самое для `baz()` и `oopsBaz()`

var p = foo( 42 );

p.then( bar, oopsBar );

p.then( baz, oopsBaz );
```
**Примечание:** Если раньше вы уже использовали промисы, то вы можете предположить, что последние две строки этого кода можно записать как `p.then( .. ).then( .. )`, используя связывание. У такого варианта было бы совершенно другое поведение, поэтому будьте осторожны! Разница может быть не совсем понятна прямо сейчас, но на самом деле это другой асинхронный шаблон:`split / forking`. Не волнуйтесь! Мы еще вернемся к этому вопросу позже в этой главе.

Вместо того, чтобы передавать промис в `bar(..)` и `baz(..)`, мы используем промис для контроля выполнения `bar(..)` и `baz(..)` , если они вообще выполнятся. Основное различие заключается в обработке ошибок.

В первом случае `bar(..)` вызывается независимо от того, как завершится `foo(..)` (успешно или нет), и обрабатывает свою собственную логику на случай, если получено уведомление, что `foo(..)` «упало». То же самое верно для `baz(..)`.

Во втором случае `bar(..)` вызывается только в том случае, если `foo(..)` завершается успешно, иначе вызывается `oopsBar(..)`. То же верно и для `baz(..)`.

Ни один из подходов не является правильным. Будут случаи, когда один предпочтительнее другого.

В любом случае промис `p`, возвращаемый от `foo(..)`, используется для контроля того, что произойдет дальше.

Более того, тот факт, что оба фрагмента заканчиваются вызовом `then(..)` иллюстрирует ранее сделанный вывод, которая заключается в том, что промисы после выполнения навсегда сохраняют одно и то же состояние (`fullfillment` или `rejection`).

Всякий раз, когда `p` выполнится, следующий шаг всегда будет таким же, как `сейчас`, так и `позже`.

## «Тогдашняя» утиная типизация

Как точно узнать, является ли какое-то значение промисом или нет. Или более точно — будет ли значение вести себя, как промис?

Учитывая, что промисы создается через  `new Promise(..)`, вы можете подумать, что `p instanceof Promise` будет истиной. Но, к сожалению, существует ряд причин, по которым это не так.

Вы можете получить значение промиса из другого окна браузера (iframe и т.д.), которое будет иметь свой собственный промис, отличный от того, который находится в текущем окне/фрейме, и проверка не сможет идентифицировать экземпляр промиса.

Более того, библиотеки или фреймворки могут предоставлять свои собственные промисы, реализация которых отличается от реализации промисов в `ES6` . Также вы вполне можете использовать промисы с библиотеками в старых браузерах, которые не поддерживают промисы.

Итак, было решено, что способ распознать промис (или что-то, что ведет себя как промис) — это определить некую сущность, называемую `«thenable»` («тогдашний»). Это любой объект или функция, у которого(-ой) есть метод `then(...)`. Предполагается, что любое такое значение является совместимым с промисом.

Общий прием для «проверки типов», который делает предположения о «типе» значения в зависимости от его свойств, называется «утиная типизация» — «Если это выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка». Таким образом, «утиная типизация» для `thenable` будет примерно такой:

```javascript
if (
	p !== null &&
	(
		typeof p === "object" ||
		typeof p === "function"
	) &&
	typeof p.then === "function"
) {
	// предположительно, это thenable!
}
else {
	// не thenable
}
```

Если вы попытаетесь выполнить промис с любым значением объекта/функции, на которых можно применить `then(..`), но при это вы не предполагали, что это промис / `thenable`, то вам не повезло. Он будет автоматически распознаваться как `thenable` и обрабатываться специальными правилами (см. далее в главе).

Это даже хорошо, если вы не осознали, что на объекте/функции есть `then(..)`. Например:

```javascript
var o = { then: function(){} };

// свяжем `v` через `[[Prototype]]` с `o`
var v = Object.create( o );

v.someStuff = "cool";
v.otherStuff = "not so cool";

v.hasOwnProperty( "then" );		// false
```

`v` не похож на промис или `thenable`. Это простой объект с некоторыми свойствами.


Но `v` при этом также является связанным через [[Prototype]] с другим объектом `o`, который имеет `then(..)`. Это значит, что проверка «утиной типизацией» покажет, что `v` это `thenable`. Нехорошо.

``` javascript
Object.prototype.then = function(){};
Array.prototype.then = function(){};

var v1 = { hello: "world" };
var v2 = [ "Hello", "World" ];
```

Предполагается, что и `v1` и `v2` будут `thenable`. Вы не можете контролировать или прогнозировать, если какой-либо другой код случайно или намеренно добавит `then(..)` в Object.prototype, Array.prototype или любой другой нативный прототип. И если указано, что это функция, которая не вызывает ни один из ее параметров в качестве колбэков, то любой промис, выполненный с таким значением, будет просто зависать навсегда!

Звучит неправдоподобно или маловероятно? Может быть.

Но имейте в виду, что перед ES6 существовало несколько известных не-промис-библиотек, у которых уже был методы, называемые `then(..)`. Некоторые из этих библиотек решили переименовать эти методы, чтобы избежать коллизий (это отстой!). Другие просто убрали эти методы из за «несовместимости с промисами».

**Предупреждение**: Мне не нравится, что мы используем «утиную типизацию» для определения промисв. Были и другие варианты, такие как «брендинг» или даже «анти-брендинг»; то, что мы получили, похоже на худший компромисс. Но не стоит отчаиваться. В некоторых случаях «утиная типизация» может быть полезна, далее мы увидим это. Нужно иметь в виду и остерегаться того, что «утиная типизация» может не правильно идентифицировать некую сущность, как промис, хотя эта сущность промисом не является.

## Промисы и проблемы доверия

Мы увидели две аналогии (будущие значения и события завершения), которые объясняют разные аспекты того, что промисы могут сделать для нашего асинхронного кода. Однако, мы еще не рассмотрели самую важную вещь, которую дают промисы: доверие.

Начнем с разбора проблем доверия, которые порождаются колбэками. Когда вы передаете колбэк утилите `foo(..)`, она может:

* Вызвать колбэк слишком рано
* Вызвать колбэк слишком поздно (или вообще не вызвать)
* Вызвать колбэк гораздо больше раз (или гораздо меньше), чем нужно
* В нее невозможно передать произвольные параметры
* Ошибки и исключения могут не обработаться

Особенности промисов решают эти проблемы

### Ранний вызов

В первую очередь проблема связана с тем, может ли код приводить к Залго-эффектам (см. Главу 2). Такое может происходить, когда задача может завершаться как синхронно, так и асинхронно, что может привести к «состоянию гонки».

Промисы по определению не подвержены этой проблеме, потому что даже незамедлительно выполненный промис (например, `new Promise(function (resolve) {resolve (42);})`) не может *наблюдаться* синхронно.

То есть, когда вы вызываете `then(..)` в промисе, даже если этот промис уже выполнен, колбэк, который вы передаете в `then(..)`, всегда будет вызываться асинхронно (более подробно об этом, в части «Задания», в главе 1).

Вам больше не нужен `setTimeout(..,0)`-хак. Промисы убивают Залго автоматически.

### Поздний вызов

Как и в предыдущем пункте, `then(..)` автоматически планируются к выполнению (по аналогии с колбэками), когда `resolve(..)` или `reject(..)` вызываются. `then(...)` будет предсказуемо запущен в следующий асинхронный момент (см. «Задания» в главе 1).

Когда промис выполнен, все `then(..) ` на нем будут вызваны по порядку, сразу при следующей асинхронной возможности (опять же, см. «Задания» в главе 1), и ничто, происходящее внутри отдельного `then'a ` не может повлиять на другие.

 Например:

 ```javascript
 p.then( function(){
 	p.then( function(){
 		console.log( "C" );
 	} );
 	console.log( "A" );
 } );
 p.then( function(){
 	console.log( "B" );
 } );
 // A B C
 ```
 Здесь «C» не может прервать и выполниться раньше «B», в силу специфики работы промисов.

#### Планирование промисов и их причуды

 Однако важно отметить, что существует множество нюансов планирования, относительно порядка выполнения отдельных промисов.

 Если оба промиса `p1` и `p2` уже разрешены, то должно быть верно, что `p1.then(..); p2.then(..)` в конечном итоге вызовет колбэк(и) для `p1` до `p2`. Но есть редкие случаи, когда это не так, например:

 ```javascript
 var p3 = new Promise( function(resolve, reject){
 	resolve( "B" );
 } );

 var p1 = new Promise( function(resolve, reject){
 	resolve( p3 );
 } );

 var p2 = new Promise( function(resolve, reject){
 	resolve( "A" );
 } );

 p1.then( function(v){
 	console.log( v );
 } );

 p2.then( function(v){
 	console.log( v );
 } );

 // A B  <-- но не  B A  как вы могли предположить
 ```

Мы рассмотрим это подробнее позже, но, как вы можете видеть, `p1` выполняется не моментально, а с другим промисом `p3`, который сам выполняется со значением «B». Специфичность этого случая в том, что `p3` разворачивается внутри `p1` асинхронно. Поэтому колбэк `p1` находится после колбэка `p2` в асинхронной очереди (см. Главу 1).

Чтобы избежать таких проблем, вы никогда не должны полагаться на порядок колбэков, вызваемых через промисы. На самом деле, хорошая практика заключается в том, чтобы не писать код таким образом, что важен порядок выполнения колбэков. Избегайте этого, если сможете.

### Колбэк, который не был вызван

Это очень распространенная проблема. Она решается несколькими путями с помощью промисов.

Во-первых, ничто (даже ошибка JS) не может помешать промису уведомить вас о его выполнении. Если вы опишите оба колбэка (`fullfillment` и `rejection`) для промиса, и промис выполнится, то один из колбэков всегда будет вызван.

Конечно, если ваши колбэки имеют ошибки, вы можете не увидеть ожидаемый результат, но колбэк при этом будут вызван. Позже мы расскажем о том, как получить уведомление об ошибке в колбэке.

Но что, если промис никогда не будет зарезолвлен? Это условие, использует абстракцию более высокого уровня, называемую «гонка»:

```javascript
// a utility for timing out a Promise
function timeoutPromise(delay) {
	return new Promise( function(resolve,reject){
		setTimeout( function(){
			reject( "Timeout!" );
		}, delay );
	} );
}

// устанавливаем таймаут для `foo()`
Promise.race( [
	foo(),					// attempt `foo()`
	timeoutPromise( 3000 )	// give it 3 seconds
] )
.then(
	function(){
		// `foo(..)` выполнилось вовремя!
	},
	function(err){
		// либо `foo()` зареджектилось, или
		// не выполнилось вовремя, нужно проверить
		// `err` чтобы узнать причину
	}
);
```

Есть больше деталей, которые следует учитывать при использовании таймаутов вместе с промисами, но мы вернемся к нем позже.

Важно отметить, что мы можем обеспечить уведомление относительно запвершения `foo()`, чтобы он не «подвешивал» программу на неопределенный срок.

### Вызов слишком мало или слишком много раз

«Слишком мало» также может означать «ноль раз», что приравнивается к «не вызовется никогда», что мы уже рассмотрели выше.

Случай «слишком много» легко объяснить. Промисы работают так, что они могут выполниться лишь один раз. Если по какой-то причине промис попытается вызвать `resolve(..)` или `reject(..)` несколько раз или пытается вызвать их оба, то будет приниматься только первый выполненный результат, а остальные будут игнорироваться.

Поскольку промис может быть выполнен только один раз, все описанные `then(...)` также вызовутся один раз.

Конечно, если вы явно опишите вызов `then()` более одного раза (например, `p.then (f); p.then (f);`), он будет вызываться столько раз, сколько был описан. Гарантия того, что функция вызывается только один раз, не мешает вам выстерелить в ногу.

### Невозможность передать произвольные параметры

Промисы могут иметь максимум одно значение выполнения (`fullfillment` или `rejection`).

Если вы явно или не явно не указываете значение, оно будет равно `undefined` (это весьма характерно для JS). При этом оно всегда будет передаваться всем зарегистрированным (и соответствующим состояниям: `fullfillment` или `rejection`) колбэкам, как *сейчас*, так и в будущем.

Нужно оговорить одну особенность: если вы вызываете `resolve(..)` или `rejection(..)` с несколькими параметрами, все последующие параметры за исключением первого игнорируются. Это может показаться нарушением правила, которое мы только что описали, но на самом деле это является неправильным использованием механизма промисов. Другие неправильные способы использования API промисов (например `resolve(..)` несколько раз) имеют такую же защиту.

Если вы хотите передать несколько значений, вы должны обернуть их в `массив` или `объект`.

Что касается среды, функции в JS всегда сохраняют замыкание области, в которой они определены , поэтому они, конечно, будут иметь доступ к любому окружающему состоянию, которое вы предоставляете. Поэтому мы можем с уверенностью положиться на это.

### Игнорирование ошибок/исключений

В определенном смысле это повторение предыдущущих выводов. Если вы отклоните (`reject`) промис по *причине* (например, сообщение об ошибке), то значение передастся в колбэк отклонения.

Но в этом утверждении кроется нечто большее. Если в любой момент создания промиса или при наблюдении за его выполнением возникает ошибка исключения JS, такая как `TypeError` или `ReferenceError`, это исключение будет поймано, и это заставит промис отклониться (перейти в состояние `rejected`).

Например:

```javascript
var p = new Promise( function(resolve, reject){
	foo.bar();	// `foo` is not defined, это ошибка!
	resolve( 42 );	// этот код никогда не выполнится :(
} );

p.then(
	function fulfilled(){
		// никогда не выполнится :(
	},
	function rejected(err){
		// `err` будут `TypeError` объектом исключения
		// полученным от `foo.bar()` строки в коде.
	}
);
```

Исключение JS, которое происходит мы получаем из `foo.bar()`, становится отклонением промиса, которое мы можем обработать.

Это важная деталь, потому что она эффективно решает проблему Залго, которая заключается в том, что ошибки могут создавать синхронную реакцию, тогда как нормальное выполнение прогрмаммы будет асинхронным. Промисы делают даже исключения JS асинхронными, тем самым значительно уменьшая шансы на условие гонки.

Но что произойдет, если промис успешно выполнится, но во время наблюдения за ним возникент ошибка исключения JS (в некотром `then(..)`)? Эти исключения не потеряются, но то ,как они будут обработаны, удивит вас:

```javascript
var p = new Promise( function(resolve, reject){
	resolve( 42 );
} );

p.then(
	function fulfilled(msg){
		foo.bar();
		console.log( msg );	// никогда не выполнится :(
	},
	function rejected(err){
		// никогда не выполнится :(
	}
);
```
Похоже, что исключение из `foo.bar()` не было зафиксировано. Но не бойтесь, это не так. Но что то внутри механизма промисов пошло не так. А именно — то, что мы не можем обработать это исключение. Вызов `p.then(..)` возвращает другой промис, и именно это промис будет отклонен с помощью исключения `TypeError`.

Почему он не мог просто вызвать обработчик ошибок, который мы там определили? Это было бы логичным поведением. Но это нарушит основополагающий принцип, согласно которому промис **иммутабелен** после выполнения. `p` уже был выполнен со значением `42`. Поэтому его нельзя позже заменить на отклонение только потому, что есть ошибка в выполнении `p`.

Помимо принципиального нарушения, такое поведение может привести к хаосу. Если, скажем, было несколько `then(..)` зарегистрированных для `p`, некоторые из них вызвались бы, а другие - нет, и было бы очень непонтяно почему.

### Надежность промисов

Это последняя деталь для изучения промисов.

Вы, несомненно, заметили, что использование промисов не отменяет использования колбэков. Они просто меняют место вызова колбэка. Вместо того, чтобы передавать колбэк `foo(..)`, мы получаем *нечто* (якобы промис) из `foo(..)`, и мы передаем колбэк этому *нечто*.

Но почему это более надежная конструкция, чем просто колбэки по-старинке? Как мы можем быть уверены, что *нечто*, которое мы получаем, это промис? Разве это вообще не просто карточный домик, где мы можем доверять только потому, что уже однажды доверились?

Одна из самых важных, но часто забываемых деталей промисов — заключается в том, что промисы решают проблему карточного домика. В нативную реализацию промисов входит `Promise.resolve(..)`.

Если вы передадите не-промис, не-thenable значение в `Promise.resolve(..)`, вы получите промис, который зарезолвится с этим значением. Другими словами, эти два промиса `p1` и `p2` будут вести себя одинаково:

```javascript
var p1 = new Promise( function(resolve, reject){
	resolve( 42 );
} );

var p2 = Promise.resolve( 42 );
```

Но, если вы передадите настоящий промис в `Promise.resolve(..)`, то вам вернется тот же самый промис:

```javascript
var p1 = Promise.resolve( 42 );

var p2 = Promise.resolve( p1 );

p1 === p2; // true
```

Помните наш предыдущий разговор о `thenable`?

Рассмотрим:

```javascript
var p = {
	then: function(cb) {
		cb( 42 );
	}
};

// это работает, но лишь благодаря счастливой случайности
p
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// код здесь никогда не выполнится
	}
);
```

`p` это `thenable` , но это не настоящий промис и что, если вам вернулось что-то такое:

```javascript
var p = {
	then: function(cb, errcb) {
		cb( 42 );
		errcb( "зловещий смех" );
	}
};

p
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// упс, это не должно запуститься
		console.log( err ); // зловещий смех
	}
);
```

`p` это `thenable`, но оно ведет себя не как промис. Является ли оно вредоносным? Или оно игнорирует механизм работы промисов? Честно говоря, это не имеет никакого значения. В любом случае, проблема доверия имеет место быть.

Тем не менее, мы можем передать любой из вариантов `p` в `Promise.resolve(..)`, и мы получим безопасный и ожидаемый результат:

```javascript
Promise.resolve( p )
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// никогда не выполнится
	}
);
```

`Promise.resolve(..)` будет принимать любые `thenable` данные и преобразует их в `не-thenable`. Из `Promise.resolve(..)` мы получаем промис, *которому вы можете доверять*. Если то, что вы передали, уже является промисом, вы просто получите его обратно.

Итак, предположим, что мы вызываем утилиту `foo(..)`, и мы не уверены, что полученное значение будет промисом. `Promise.resolve(..)` предоставит нам надежную обертку в виде промиса:

```javascript
// не делайте так:
foo( 42 )
.then( function(v){
	console.log( v );
} );

// делайте так:
Promise.resolve( foo( 42 ) )
.then( function(v){
	console.log( v );
} );
```

**Примечание**: другой положительный эффект от оборачивания функции в `Promise.resolve(..)` — это легкий способ вызвать функцию асинхронно. `foo(..)` может или немедленно вернуть значение или вернуть промис. `Promise.resolve(..)` гарантирует, что возвращаемое значение всегда будет промисом.

### Доверие получено

Надеюсь, теперь в вашем сознании полностью «зарезолвилось» понимание надежности промисов. И что еще более важно у вас появилось понимание, почему эта надежность настолько важна для создания универсального, поддерживаемого программного обеспечения.

Можете ли вы писать асинхронный код в JS «на авось»? Конечно можете. Разработчики на JS, писали асинхронный код не имея ничего, кроме колбэков в течение почти двух десятилетий.

Но когда вы начинаете задумываться, насколько такие решения предсказуемы и надежны, то вы начинаете понимать, что на одни только колбэки нельзя положиться.

Промисы - это решение, которое дополняет колбэки надежной семантикой, делая их поведение более разумным и надежным. Нейтрализуя инверсию контроля колбэков, мы получаем надежную систему, которая была разработана специально для внесения здравого смысла в асинхронные программы.

## Связывание

Важно понимать, что промисы - это не просто механизм для одноэтапной операции `это-затем-то`. Оказывается мы можем объединить несколько промисов вместе, чтобы создать последовательность асинхронных шагов.

Ключ к использованию связывания, заключается в двух особенностях:

* Каждый раз, когда вы вызываете `then(..)` ,он создает и возвращает новый промис, связанный с предыдущим
* Независимо от того, какое значение вы вернете из fullfillment-колбэка `then(...)` (первый параметр), это значение автоматически попадет в fullfillment-колбэк `связанного` промиса.

Давайте сначала проиллюстрируем, что это значит, и тогда мы узнаем, как это помогает нам создавать асинхронные последовательности:

```javascript
var p = Promise.resolve( 21 );

var p2 = p.then( function(v){
	console.log( v );	// 21

	// fulfillment `p2` со значением `42`
	return v * 2;
} );

// chain off `p2`
p2.then( function(v){
	console.log( v );	// 42
} );
```
